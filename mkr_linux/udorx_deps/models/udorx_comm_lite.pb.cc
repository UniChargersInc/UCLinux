// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: udorx_comm_lite.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "udorx_comm_lite.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace udorx_comm_lite {

void protobuf_ShutdownFile_udorx_5fcomm_5flite_2eproto() {
  delete CLogin::default_instance_;
  delete RttHB::default_instance_;
  delete ClsLoginMD::default_instance_;
  delete RttHBResp::default_instance_;
  delete PIRptMFile::default_instance_;
  delete PMMsgList::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_udorx_5fcomm_5flite_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_udorx_5fcomm_5flite_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::udorx_comm_lite::protobuf_AddDesc_udorx_5fcommon_5flite_2eproto();
  CLogin::default_instance_ = new CLogin();
  RttHB::default_instance_ = new RttHB();
  ClsLoginMD::default_instance_ = new ClsLoginMD();
  RttHBResp::default_instance_ = new RttHBResp();
  PIRptMFile::default_instance_ = new PIRptMFile();
  PMMsgList::default_instance_ = new PMMsgList();
  CLogin::default_instance_->InitAsDefaultInstance();
  RttHB::default_instance_->InitAsDefaultInstance();
  ClsLoginMD::default_instance_->InitAsDefaultInstance();
  RttHBResp::default_instance_->InitAsDefaultInstance();
  PIRptMFile::default_instance_->InitAsDefaultInstance();
  PMMsgList::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_udorx_5fcomm_5flite_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_udorx_5fcomm_5flite_2eproto_once_);
void protobuf_AddDesc_udorx_5fcomm_5flite_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_udorx_5fcomm_5flite_2eproto_once_,
                 &protobuf_AddDesc_udorx_5fcomm_5flite_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_udorx_5fcomm_5flite_2eproto {
  StaticDescriptorInitializer_udorx_5fcomm_5flite_2eproto() {
    protobuf_AddDesc_udorx_5fcomm_5flite_2eproto();
  }
} static_descriptor_initializer_udorx_5fcomm_5flite_2eproto_;
#endif

namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CLogin::kResFieldNumber;
const int CLogin::kCidFieldNumber;
const int CLogin::kUserFieldNumber;
const int CLogin::kPassFieldNumber;
const int CLogin::kLangFieldNumber;
const int CLogin::kSiFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CLogin::CLogin()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:udorx_comm_lite.CLogin)
}

void CLogin::InitAsDefaultInstance() {
}

CLogin::CLogin(const CLogin& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:udorx_comm_lite.CLogin)
}

void CLogin::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  res_ = 0;
  cid_ = 0;
  user_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  pass_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  lang_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  si_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CLogin::~CLogin() {
  // @@protoc_insertion_point(destructor:udorx_comm_lite.CLogin)
  SharedDtor();
}

void CLogin::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  pass_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  lang_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CLogin::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CLogin& CLogin::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_udorx_5fcomm_5flite_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_udorx_5fcomm_5flite_2eproto();
#endif
  return *default_instance_;
}

CLogin* CLogin::default_instance_ = NULL;

CLogin* CLogin::New(::google::protobuf::Arena* arena) const {
  CLogin* n = new CLogin;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CLogin::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<CLogin*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 63u) {
    ZR_(res_, cid_);
    if (has_user()) {
      user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_pass()) {
      pass_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_lang()) {
      lang_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    si_ = GOOGLE_LONGLONG(0);
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool CLogin::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:udorx_comm_lite.CLogin)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 res = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &res_)));
          set_has_res();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_cid;
        break;
      }

      // required int32 cid = 2;
      case 2: {
        if (tag == 16) {
         parse_cid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &cid_)));
          set_has_cid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_user;
        break;
      }

      // required string user = 3;
      case 3: {
        if (tag == 26) {
         parse_user:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_pass;
        break;
      }

      // required string pass = 4;
      case 4: {
        if (tag == 34) {
         parse_pass:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pass()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_lang;
        break;
      }

      // required string lang = 5;
      case 5: {
        if (tag == 42) {
         parse_lang:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_lang()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_si;
        break;
      }

      // required int64 si = 6;
      case 6: {
        if (tag == 48) {
         parse_si:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &si_)));
          set_has_si();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:udorx_comm_lite.CLogin)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:udorx_comm_lite.CLogin)
  return false;
#undef DO_
}

void CLogin::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:udorx_comm_lite.CLogin)
  // required int32 res = 1;
  if (has_res()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->res(), output);
  }

  // required int32 cid = 2;
  if (has_cid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->cid(), output);
  }

  // required string user = 3;
  if (has_user()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->user(), output);
  }

  // required string pass = 4;
  if (has_pass()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->pass(), output);
  }

  // required string lang = 5;
  if (has_lang()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->lang(), output);
  }

  // required int64 si = 6;
  if (has_si()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(6, this->si(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:udorx_comm_lite.CLogin)
}

int CLogin::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_res()) {
    // required int32 res = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->res());
  }

  if (has_cid()) {
    // required int32 cid = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->cid());
  }

  if (has_user()) {
    // required string user = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->user());
  }

  if (has_pass()) {
    // required string pass = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->pass());
  }

  if (has_lang()) {
    // required string lang = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->lang());
  }

  if (has_si()) {
    // required int64 si = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->si());
  }

  return total_size;
}
int CLogin::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000003f) ^ 0x0000003f) == 0) {  // All required fields are present.
    // required int32 res = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->res());

    // required int32 cid = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->cid());

    // required string user = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->user());

    // required string pass = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->pass());

    // required string lang = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->lang());

    // required int64 si = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->si());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CLogin::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CLogin*>(&from));
}

void CLogin::MergeFrom(const CLogin& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_res()) {
      set_res(from.res());
    }
    if (from.has_cid()) {
      set_cid(from.cid());
    }
    if (from.has_user()) {
      set_has_user();
      user_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.user_);
    }
    if (from.has_pass()) {
      set_has_pass();
      pass_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.pass_);
    }
    if (from.has_lang()) {
      set_has_lang();
      lang_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.lang_);
    }
    if (from.has_si()) {
      set_si(from.si());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CLogin::CopyFrom(const CLogin& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CLogin::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void CLogin::Swap(CLogin* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CLogin::InternalSwap(CLogin* other) {
  std::swap(res_, other->res_);
  std::swap(cid_, other->cid_);
  user_.Swap(&other->user_);
  pass_.Swap(&other->pass_);
  lang_.Swap(&other->lang_);
  std::swap(si_, other->si_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string CLogin::GetTypeName() const {
  return "udorx_comm_lite.CLogin";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CLogin

// required int32 res = 1;
bool CLogin::has_res() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CLogin::set_has_res() {
  _has_bits_[0] |= 0x00000001u;
}
void CLogin::clear_has_res() {
  _has_bits_[0] &= ~0x00000001u;
}
void CLogin::clear_res() {
  res_ = 0;
  clear_has_res();
}
 ::google::protobuf::int32 CLogin::res() const {
  // @@protoc_insertion_point(field_get:udorx_comm_lite.CLogin.res)
  return res_;
}
 void CLogin::set_res(::google::protobuf::int32 value) {
  set_has_res();
  res_ = value;
  // @@protoc_insertion_point(field_set:udorx_comm_lite.CLogin.res)
}

// required int32 cid = 2;
bool CLogin::has_cid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CLogin::set_has_cid() {
  _has_bits_[0] |= 0x00000002u;
}
void CLogin::clear_has_cid() {
  _has_bits_[0] &= ~0x00000002u;
}
void CLogin::clear_cid() {
  cid_ = 0;
  clear_has_cid();
}
 ::google::protobuf::int32 CLogin::cid() const {
  // @@protoc_insertion_point(field_get:udorx_comm_lite.CLogin.cid)
  return cid_;
}
 void CLogin::set_cid(::google::protobuf::int32 value) {
  set_has_cid();
  cid_ = value;
  // @@protoc_insertion_point(field_set:udorx_comm_lite.CLogin.cid)
}

// required string user = 3;
bool CLogin::has_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CLogin::set_has_user() {
  _has_bits_[0] |= 0x00000004u;
}
void CLogin::clear_has_user() {
  _has_bits_[0] &= ~0x00000004u;
}
void CLogin::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user();
}
 const ::std::string& CLogin::user() const {
  // @@protoc_insertion_point(field_get:udorx_comm_lite.CLogin.user)
  return user_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CLogin::set_user(const ::std::string& value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:udorx_comm_lite.CLogin.user)
}
 void CLogin::set_user(const char* value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:udorx_comm_lite.CLogin.user)
}
 void CLogin::set_user(const char* value, size_t size) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:udorx_comm_lite.CLogin.user)
}
 ::std::string* CLogin::mutable_user() {
  set_has_user();
  // @@protoc_insertion_point(field_mutable:udorx_comm_lite.CLogin.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* CLogin::release_user() {
  clear_has_user();
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CLogin::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    set_has_user();
  } else {
    clear_has_user();
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:udorx_comm_lite.CLogin.user)
}

// required string pass = 4;
bool CLogin::has_pass() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void CLogin::set_has_pass() {
  _has_bits_[0] |= 0x00000008u;
}
void CLogin::clear_has_pass() {
  _has_bits_[0] &= ~0x00000008u;
}
void CLogin::clear_pass() {
  pass_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pass();
}
 const ::std::string& CLogin::pass() const {
  // @@protoc_insertion_point(field_get:udorx_comm_lite.CLogin.pass)
  return pass_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CLogin::set_pass(const ::std::string& value) {
  set_has_pass();
  pass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:udorx_comm_lite.CLogin.pass)
}
 void CLogin::set_pass(const char* value) {
  set_has_pass();
  pass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:udorx_comm_lite.CLogin.pass)
}
 void CLogin::set_pass(const char* value, size_t size) {
  set_has_pass();
  pass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:udorx_comm_lite.CLogin.pass)
}
 ::std::string* CLogin::mutable_pass() {
  set_has_pass();
  // @@protoc_insertion_point(field_mutable:udorx_comm_lite.CLogin.pass)
  return pass_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* CLogin::release_pass() {
  clear_has_pass();
  return pass_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CLogin::set_allocated_pass(::std::string* pass) {
  if (pass != NULL) {
    set_has_pass();
  } else {
    clear_has_pass();
  }
  pass_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pass);
  // @@protoc_insertion_point(field_set_allocated:udorx_comm_lite.CLogin.pass)
}

// required string lang = 5;
bool CLogin::has_lang() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void CLogin::set_has_lang() {
  _has_bits_[0] |= 0x00000010u;
}
void CLogin::clear_has_lang() {
  _has_bits_[0] &= ~0x00000010u;
}
void CLogin::clear_lang() {
  lang_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_lang();
}
 const ::std::string& CLogin::lang() const {
  // @@protoc_insertion_point(field_get:udorx_comm_lite.CLogin.lang)
  return lang_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CLogin::set_lang(const ::std::string& value) {
  set_has_lang();
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:udorx_comm_lite.CLogin.lang)
}
 void CLogin::set_lang(const char* value) {
  set_has_lang();
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:udorx_comm_lite.CLogin.lang)
}
 void CLogin::set_lang(const char* value, size_t size) {
  set_has_lang();
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:udorx_comm_lite.CLogin.lang)
}
 ::std::string* CLogin::mutable_lang() {
  set_has_lang();
  // @@protoc_insertion_point(field_mutable:udorx_comm_lite.CLogin.lang)
  return lang_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* CLogin::release_lang() {
  clear_has_lang();
  return lang_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CLogin::set_allocated_lang(::std::string* lang) {
  if (lang != NULL) {
    set_has_lang();
  } else {
    clear_has_lang();
  }
  lang_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lang);
  // @@protoc_insertion_point(field_set_allocated:udorx_comm_lite.CLogin.lang)
}

// required int64 si = 6;
bool CLogin::has_si() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void CLogin::set_has_si() {
  _has_bits_[0] |= 0x00000020u;
}
void CLogin::clear_has_si() {
  _has_bits_[0] &= ~0x00000020u;
}
void CLogin::clear_si() {
  si_ = GOOGLE_LONGLONG(0);
  clear_has_si();
}
 ::google::protobuf::int64 CLogin::si() const {
  // @@protoc_insertion_point(field_get:udorx_comm_lite.CLogin.si)
  return si_;
}
 void CLogin::set_si(::google::protobuf::int64 value) {
  set_has_si();
  si_ = value;
  // @@protoc_insertion_point(field_set:udorx_comm_lite.CLogin.si)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RttHB::kRidFieldNumber;
const int RttHB::kLatFieldNumber;
const int RttHB::kLonFieldNumber;
const int RttHB::kSpdFieldNumber;
const int RttHB::kCogFieldNumber;
const int RttHB::kTsFieldNumber;
const int RttHB::kDevtypeFieldNumber;
const int RttHB::kDidFieldNumber;
const int RttHB::kSensorsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RttHB::RttHB()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:udorx_comm_lite.RttHB)
}

void RttHB::InitAsDefaultInstance() {
}

RttHB::RttHB(const RttHB& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:udorx_comm_lite.RttHB)
}

void RttHB::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  rid_ = 0;
  lat_ = 0;
  lon_ = 0;
  spd_ = 0;
  cog_ = 0;
  ts_ = GOOGLE_LONGLONG(0);
  devtype_ = 0;
  did_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sensors_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RttHB::~RttHB() {
  // @@protoc_insertion_point(destructor:udorx_comm_lite.RttHB)
  SharedDtor();
}

void RttHB::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  did_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sensors_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RttHB::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RttHB& RttHB::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_udorx_5fcomm_5flite_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_udorx_5fcomm_5flite_2eproto();
#endif
  return *default_instance_;
}

RttHB* RttHB::default_instance_ = NULL;

RttHB* RttHB::New(::google::protobuf::Arena* arena) const {
  RttHB* n = new RttHB;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RttHB::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<RttHB*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(rid_, devtype_);
    if (has_did()) {
      did_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  if (has_sensors()) {
    sensors_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool RttHB::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:udorx_comm_lite.RttHB)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required sint32 rid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &rid_)));
          set_has_rid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_lat;
        break;
      }

      // required float lat = 2;
      case 2: {
        if (tag == 21) {
         parse_lat:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &lat_)));
          set_has_lat();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_lon;
        break;
      }

      // required float lon = 3;
      case 3: {
        if (tag == 29) {
         parse_lon:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &lon_)));
          set_has_lon();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_spd;
        break;
      }

      // required int32 spd = 4;
      case 4: {
        if (tag == 32) {
         parse_spd:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &spd_)));
          set_has_spd();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_cog;
        break;
      }

      // required int32 cog = 5;
      case 5: {
        if (tag == 40) {
         parse_cog:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &cog_)));
          set_has_cog();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_ts;
        break;
      }

      // required int64 ts = 6;
      case 6: {
        if (tag == 48) {
         parse_ts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &ts_)));
          set_has_ts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_devtype;
        break;
      }

      // optional int32 devtype = 7;
      case 7: {
        if (tag == 56) {
         parse_devtype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &devtype_)));
          set_has_devtype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_did;
        break;
      }

      // optional string did = 8;
      case 8: {
        if (tag == 66) {
         parse_did:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_did()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_sensors;
        break;
      }

      // optional string sensors = 9;
      case 9: {
        if (tag == 74) {
         parse_sensors:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sensors()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:udorx_comm_lite.RttHB)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:udorx_comm_lite.RttHB)
  return false;
#undef DO_
}

void RttHB::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:udorx_comm_lite.RttHB)
  // required sint32 rid = 1;
  if (has_rid()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(1, this->rid(), output);
  }

  // required float lat = 2;
  if (has_lat()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->lat(), output);
  }

  // required float lon = 3;
  if (has_lon()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->lon(), output);
  }

  // required int32 spd = 4;
  if (has_spd()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->spd(), output);
  }

  // required int32 cog = 5;
  if (has_cog()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->cog(), output);
  }

  // required int64 ts = 6;
  if (has_ts()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(6, this->ts(), output);
  }

  // optional int32 devtype = 7;
  if (has_devtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->devtype(), output);
  }

  // optional string did = 8;
  if (has_did()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->did(), output);
  }

  // optional string sensors = 9;
  if (has_sensors()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      9, this->sensors(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:udorx_comm_lite.RttHB)
}

int RttHB::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_rid()) {
    // required sint32 rid = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::SInt32Size(
        this->rid());
  }

  if (has_lat()) {
    // required float lat = 2;
    total_size += 1 + 4;
  }

  if (has_lon()) {
    // required float lon = 3;
    total_size += 1 + 4;
  }

  if (has_spd()) {
    // required int32 spd = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->spd());
  }

  if (has_cog()) {
    // required int32 cog = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->cog());
  }

  if (has_ts()) {
    // required int64 ts = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->ts());
  }

  return total_size;
}
int RttHB::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000003f) ^ 0x0000003f) == 0) {  // All required fields are present.
    // required sint32 rid = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::SInt32Size(
        this->rid());

    // required float lat = 2;
    total_size += 1 + 4;

    // required float lon = 3;
    total_size += 1 + 4;

    // required int32 spd = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->spd());

    // required int32 cog = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->cog());

    // required int64 ts = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->ts());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[6 / 32] & 192u) {
    // optional int32 devtype = 7;
    if (has_devtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->devtype());
    }

    // optional string did = 8;
    if (has_did()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->did());
    }

  }
  // optional string sensors = 9;
  if (has_sensors()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->sensors());
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RttHB::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RttHB*>(&from));
}

void RttHB::MergeFrom(const RttHB& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rid()) {
      set_rid(from.rid());
    }
    if (from.has_lat()) {
      set_lat(from.lat());
    }
    if (from.has_lon()) {
      set_lon(from.lon());
    }
    if (from.has_spd()) {
      set_spd(from.spd());
    }
    if (from.has_cog()) {
      set_cog(from.cog());
    }
    if (from.has_ts()) {
      set_ts(from.ts());
    }
    if (from.has_devtype()) {
      set_devtype(from.devtype());
    }
    if (from.has_did()) {
      set_has_did();
      did_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.did_);
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_sensors()) {
      set_has_sensors();
      sensors_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sensors_);
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RttHB::CopyFrom(const RttHB& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RttHB::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void RttHB::Swap(RttHB* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RttHB::InternalSwap(RttHB* other) {
  std::swap(rid_, other->rid_);
  std::swap(lat_, other->lat_);
  std::swap(lon_, other->lon_);
  std::swap(spd_, other->spd_);
  std::swap(cog_, other->cog_);
  std::swap(ts_, other->ts_);
  std::swap(devtype_, other->devtype_);
  did_.Swap(&other->did_);
  sensors_.Swap(&other->sensors_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string RttHB::GetTypeName() const {
  return "udorx_comm_lite.RttHB";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RttHB

// required sint32 rid = 1;
bool RttHB::has_rid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RttHB::set_has_rid() {
  _has_bits_[0] |= 0x00000001u;
}
void RttHB::clear_has_rid() {
  _has_bits_[0] &= ~0x00000001u;
}
void RttHB::clear_rid() {
  rid_ = 0;
  clear_has_rid();
}
 ::google::protobuf::int32 RttHB::rid() const {
  // @@protoc_insertion_point(field_get:udorx_comm_lite.RttHB.rid)
  return rid_;
}
 void RttHB::set_rid(::google::protobuf::int32 value) {
  set_has_rid();
  rid_ = value;
  // @@protoc_insertion_point(field_set:udorx_comm_lite.RttHB.rid)
}

// required float lat = 2;
bool RttHB::has_lat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RttHB::set_has_lat() {
  _has_bits_[0] |= 0x00000002u;
}
void RttHB::clear_has_lat() {
  _has_bits_[0] &= ~0x00000002u;
}
void RttHB::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
 float RttHB::lat() const {
  // @@protoc_insertion_point(field_get:udorx_comm_lite.RttHB.lat)
  return lat_;
}
 void RttHB::set_lat(float value) {
  set_has_lat();
  lat_ = value;
  // @@protoc_insertion_point(field_set:udorx_comm_lite.RttHB.lat)
}

// required float lon = 3;
bool RttHB::has_lon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RttHB::set_has_lon() {
  _has_bits_[0] |= 0x00000004u;
}
void RttHB::clear_has_lon() {
  _has_bits_[0] &= ~0x00000004u;
}
void RttHB::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
 float RttHB::lon() const {
  // @@protoc_insertion_point(field_get:udorx_comm_lite.RttHB.lon)
  return lon_;
}
 void RttHB::set_lon(float value) {
  set_has_lon();
  lon_ = value;
  // @@protoc_insertion_point(field_set:udorx_comm_lite.RttHB.lon)
}

// required int32 spd = 4;
bool RttHB::has_spd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void RttHB::set_has_spd() {
  _has_bits_[0] |= 0x00000008u;
}
void RttHB::clear_has_spd() {
  _has_bits_[0] &= ~0x00000008u;
}
void RttHB::clear_spd() {
  spd_ = 0;
  clear_has_spd();
}
 ::google::protobuf::int32 RttHB::spd() const {
  // @@protoc_insertion_point(field_get:udorx_comm_lite.RttHB.spd)
  return spd_;
}
 void RttHB::set_spd(::google::protobuf::int32 value) {
  set_has_spd();
  spd_ = value;
  // @@protoc_insertion_point(field_set:udorx_comm_lite.RttHB.spd)
}

// required int32 cog = 5;
bool RttHB::has_cog() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void RttHB::set_has_cog() {
  _has_bits_[0] |= 0x00000010u;
}
void RttHB::clear_has_cog() {
  _has_bits_[0] &= ~0x00000010u;
}
void RttHB::clear_cog() {
  cog_ = 0;
  clear_has_cog();
}
 ::google::protobuf::int32 RttHB::cog() const {
  // @@protoc_insertion_point(field_get:udorx_comm_lite.RttHB.cog)
  return cog_;
}
 void RttHB::set_cog(::google::protobuf::int32 value) {
  set_has_cog();
  cog_ = value;
  // @@protoc_insertion_point(field_set:udorx_comm_lite.RttHB.cog)
}

// required int64 ts = 6;
bool RttHB::has_ts() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void RttHB::set_has_ts() {
  _has_bits_[0] |= 0x00000020u;
}
void RttHB::clear_has_ts() {
  _has_bits_[0] &= ~0x00000020u;
}
void RttHB::clear_ts() {
  ts_ = GOOGLE_LONGLONG(0);
  clear_has_ts();
}
 ::google::protobuf::int64 RttHB::ts() const {
  // @@protoc_insertion_point(field_get:udorx_comm_lite.RttHB.ts)
  return ts_;
}
 void RttHB::set_ts(::google::protobuf::int64 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:udorx_comm_lite.RttHB.ts)
}

// optional int32 devtype = 7;
bool RttHB::has_devtype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void RttHB::set_has_devtype() {
  _has_bits_[0] |= 0x00000040u;
}
void RttHB::clear_has_devtype() {
  _has_bits_[0] &= ~0x00000040u;
}
void RttHB::clear_devtype() {
  devtype_ = 0;
  clear_has_devtype();
}
 ::google::protobuf::int32 RttHB::devtype() const {
  // @@protoc_insertion_point(field_get:udorx_comm_lite.RttHB.devtype)
  return devtype_;
}
 void RttHB::set_devtype(::google::protobuf::int32 value) {
  set_has_devtype();
  devtype_ = value;
  // @@protoc_insertion_point(field_set:udorx_comm_lite.RttHB.devtype)
}

// optional string did = 8;
bool RttHB::has_did() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void RttHB::set_has_did() {
  _has_bits_[0] |= 0x00000080u;
}
void RttHB::clear_has_did() {
  _has_bits_[0] &= ~0x00000080u;
}
void RttHB::clear_did() {
  did_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_did();
}
 const ::std::string& RttHB::did() const {
  // @@protoc_insertion_point(field_get:udorx_comm_lite.RttHB.did)
  return did_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RttHB::set_did(const ::std::string& value) {
  set_has_did();
  did_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:udorx_comm_lite.RttHB.did)
}
 void RttHB::set_did(const char* value) {
  set_has_did();
  did_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:udorx_comm_lite.RttHB.did)
}
 void RttHB::set_did(const char* value, size_t size) {
  set_has_did();
  did_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:udorx_comm_lite.RttHB.did)
}
 ::std::string* RttHB::mutable_did() {
  set_has_did();
  // @@protoc_insertion_point(field_mutable:udorx_comm_lite.RttHB.did)
  return did_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RttHB::release_did() {
  clear_has_did();
  return did_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RttHB::set_allocated_did(::std::string* did) {
  if (did != NULL) {
    set_has_did();
  } else {
    clear_has_did();
  }
  did_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), did);
  // @@protoc_insertion_point(field_set_allocated:udorx_comm_lite.RttHB.did)
}

// optional string sensors = 9;
bool RttHB::has_sensors() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void RttHB::set_has_sensors() {
  _has_bits_[0] |= 0x00000100u;
}
void RttHB::clear_has_sensors() {
  _has_bits_[0] &= ~0x00000100u;
}
void RttHB::clear_sensors() {
  sensors_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sensors();
}
 const ::std::string& RttHB::sensors() const {
  // @@protoc_insertion_point(field_get:udorx_comm_lite.RttHB.sensors)
  return sensors_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RttHB::set_sensors(const ::std::string& value) {
  set_has_sensors();
  sensors_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:udorx_comm_lite.RttHB.sensors)
}
 void RttHB::set_sensors(const char* value) {
  set_has_sensors();
  sensors_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:udorx_comm_lite.RttHB.sensors)
}
 void RttHB::set_sensors(const char* value, size_t size) {
  set_has_sensors();
  sensors_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:udorx_comm_lite.RttHB.sensors)
}
 ::std::string* RttHB::mutable_sensors() {
  set_has_sensors();
  // @@protoc_insertion_point(field_mutable:udorx_comm_lite.RttHB.sensors)
  return sensors_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RttHB::release_sensors() {
  clear_has_sensors();
  return sensors_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RttHB::set_allocated_sensors(::std::string* sensors) {
  if (sensors != NULL) {
    set_has_sensors();
  } else {
    clear_has_sensors();
  }
  sensors_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sensors);
  // @@protoc_insertion_point(field_set_allocated:udorx_comm_lite.RttHB.sensors)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ClsLoginMD::kLgnFieldNumber;
const int ClsLoginMD::kRIDFieldNumber;
const int ClsLoginMD::kDrNameFieldNumber;
const int ClsLoginMD::kCsStationsFieldNumber;
const int ClsLoginMD::kConfigFieldNumber;
const int ClsLoginMD::kDriverProfFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ClsLoginMD::ClsLoginMD()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:udorx_comm_lite.ClsLoginMD)
}

void ClsLoginMD::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  lgn_ = const_cast< ::udorx_comm_lite::CLogin*>(
      ::udorx_comm_lite::CLogin::internal_default_instance());
#else
  lgn_ = const_cast< ::udorx_comm_lite::CLogin*>(&::udorx_comm_lite::CLogin::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  cs_stations_ = const_cast< ::udorx_comm_lite::PCSList*>(
      ::udorx_comm_lite::PCSList::internal_default_instance());
#else
  cs_stations_ = const_cast< ::udorx_comm_lite::PCSList*>(&::udorx_comm_lite::PCSList::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  config_ = const_cast< ::udorx_comm_lite::PConf*>(
      ::udorx_comm_lite::PConf::internal_default_instance());
#else
  config_ = const_cast< ::udorx_comm_lite::PConf*>(&::udorx_comm_lite::PConf::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  driverprof_ = const_cast< ::udorx_comm_lite::PEmpl*>(
      ::udorx_comm_lite::PEmpl::internal_default_instance());
#else
  driverprof_ = const_cast< ::udorx_comm_lite::PEmpl*>(&::udorx_comm_lite::PEmpl::default_instance());
#endif
}

ClsLoginMD::ClsLoginMD(const ClsLoginMD& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:udorx_comm_lite.ClsLoginMD)
}

void ClsLoginMD::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  lgn_ = NULL;
  rid_ = 0;
  drname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  cs_stations_ = NULL;
  config_ = NULL;
  driverprof_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClsLoginMD::~ClsLoginMD() {
  // @@protoc_insertion_point(destructor:udorx_comm_lite.ClsLoginMD)
  SharedDtor();
}

void ClsLoginMD::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  drname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete lgn_;
    delete cs_stations_;
    delete config_;
    delete driverprof_;
  }
}

void ClsLoginMD::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ClsLoginMD& ClsLoginMD::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_udorx_5fcomm_5flite_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_udorx_5fcomm_5flite_2eproto();
#endif
  return *default_instance_;
}

ClsLoginMD* ClsLoginMD::default_instance_ = NULL;

ClsLoginMD* ClsLoginMD::New(::google::protobuf::Arena* arena) const {
  ClsLoginMD* n = new ClsLoginMD;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ClsLoginMD::Clear() {
  if (_has_bits_[0 / 32] & 63u) {
    if (has_lgn()) {
      if (lgn_ != NULL) lgn_->::udorx_comm_lite::CLogin::Clear();
    }
    rid_ = 0;
    if (has_drname()) {
      drname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_cs_stations()) {
      if (cs_stations_ != NULL) cs_stations_->::udorx_comm_lite::PCSList::Clear();
    }
    if (has_config()) {
      if (config_ != NULL) config_->::udorx_comm_lite::PConf::Clear();
    }
    if (has_driverprof()) {
      if (driverprof_ != NULL) driverprof_->::udorx_comm_lite::PEmpl::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ClsLoginMD::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:udorx_comm_lite.ClsLoginMD)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .udorx_comm_lite.CLogin lgn = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lgn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_RID;
        break;
      }

      // optional int32 RID = 2;
      case 2: {
        if (tag == 16) {
         parse_RID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &rid_)));
          set_has_rid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_DrName;
        break;
      }

      // optional string DrName = 3;
      case 3: {
        if (tag == 26) {
         parse_DrName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_drname()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_cs_stations;
        break;
      }

      // optional .udorx_comm_lite.PCSList cs_stations = 4;
      case 4: {
        if (tag == 34) {
         parse_cs_stations:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cs_stations()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_config;
        break;
      }

      // optional .udorx_comm_lite.PConf config = 5;
      case 5: {
        if (tag == 42) {
         parse_config:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_driverProf;
        break;
      }

      // optional .udorx_comm_lite.PEmpl driverProf = 6;
      case 6: {
        if (tag == 50) {
         parse_driverProf:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_driverprof()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:udorx_comm_lite.ClsLoginMD)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:udorx_comm_lite.ClsLoginMD)
  return false;
#undef DO_
}

void ClsLoginMD::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:udorx_comm_lite.ClsLoginMD)
  // required .udorx_comm_lite.CLogin lgn = 1;
  if (has_lgn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->lgn_, output);
  }

  // optional int32 RID = 2;
  if (has_rid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->rid(), output);
  }

  // optional string DrName = 3;
  if (has_drname()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->drname(), output);
  }

  // optional .udorx_comm_lite.PCSList cs_stations = 4;
  if (has_cs_stations()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->cs_stations_, output);
  }

  // optional .udorx_comm_lite.PConf config = 5;
  if (has_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, *this->config_, output);
  }

  // optional .udorx_comm_lite.PEmpl driverProf = 6;
  if (has_driverprof()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, *this->driverprof_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:udorx_comm_lite.ClsLoginMD)
}

int ClsLoginMD::ByteSize() const {
  int total_size = 0;

  // required .udorx_comm_lite.CLogin lgn = 1;
  if (has_lgn()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->lgn_);
  }
  if (_has_bits_[1 / 32] & 62u) {
    // optional int32 RID = 2;
    if (has_rid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->rid());
    }

    // optional string DrName = 3;
    if (has_drname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->drname());
    }

    // optional .udorx_comm_lite.PCSList cs_stations = 4;
    if (has_cs_stations()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->cs_stations_);
    }

    // optional .udorx_comm_lite.PConf config = 5;
    if (has_config()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->config_);
    }

    // optional .udorx_comm_lite.PEmpl driverProf = 6;
    if (has_driverprof()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->driverprof_);
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClsLoginMD::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ClsLoginMD*>(&from));
}

void ClsLoginMD::MergeFrom(const ClsLoginMD& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_lgn()) {
      mutable_lgn()->::udorx_comm_lite::CLogin::MergeFrom(from.lgn());
    }
    if (from.has_rid()) {
      set_rid(from.rid());
    }
    if (from.has_drname()) {
      set_has_drname();
      drname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.drname_);
    }
    if (from.has_cs_stations()) {
      mutable_cs_stations()->::udorx_comm_lite::PCSList::MergeFrom(from.cs_stations());
    }
    if (from.has_config()) {
      mutable_config()->::udorx_comm_lite::PConf::MergeFrom(from.config());
    }
    if (from.has_driverprof()) {
      mutable_driverprof()->::udorx_comm_lite::PEmpl::MergeFrom(from.driverprof());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ClsLoginMD::CopyFrom(const ClsLoginMD& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClsLoginMD::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_lgn()) {
    if (!this->lgn_->IsInitialized()) return false;
  }
  if (has_cs_stations()) {
    if (!this->cs_stations_->IsInitialized()) return false;
  }
  if (has_config()) {
    if (!this->config_->IsInitialized()) return false;
  }
  if (has_driverprof()) {
    if (!this->driverprof_->IsInitialized()) return false;
  }
  return true;
}

void ClsLoginMD::Swap(ClsLoginMD* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ClsLoginMD::InternalSwap(ClsLoginMD* other) {
  std::swap(lgn_, other->lgn_);
  std::swap(rid_, other->rid_);
  drname_.Swap(&other->drname_);
  std::swap(cs_stations_, other->cs_stations_);
  std::swap(config_, other->config_);
  std::swap(driverprof_, other->driverprof_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ClsLoginMD::GetTypeName() const {
  return "udorx_comm_lite.ClsLoginMD";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ClsLoginMD

// required .udorx_comm_lite.CLogin lgn = 1;
bool ClsLoginMD::has_lgn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ClsLoginMD::set_has_lgn() {
  _has_bits_[0] |= 0x00000001u;
}
void ClsLoginMD::clear_has_lgn() {
  _has_bits_[0] &= ~0x00000001u;
}
void ClsLoginMD::clear_lgn() {
  if (lgn_ != NULL) lgn_->::udorx_comm_lite::CLogin::Clear();
  clear_has_lgn();
}
const ::udorx_comm_lite::CLogin& ClsLoginMD::lgn() const {
  // @@protoc_insertion_point(field_get:udorx_comm_lite.ClsLoginMD.lgn)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return lgn_ != NULL ? *lgn_ : *default_instance().lgn_;
#else
  return lgn_ != NULL ? *lgn_ : *default_instance_->lgn_;
#endif
}
::udorx_comm_lite::CLogin* ClsLoginMD::mutable_lgn() {
  set_has_lgn();
  if (lgn_ == NULL) {
    lgn_ = new ::udorx_comm_lite::CLogin;
  }
  // @@protoc_insertion_point(field_mutable:udorx_comm_lite.ClsLoginMD.lgn)
  return lgn_;
}
::udorx_comm_lite::CLogin* ClsLoginMD::release_lgn() {
  clear_has_lgn();
  ::udorx_comm_lite::CLogin* temp = lgn_;
  lgn_ = NULL;
  return temp;
}
void ClsLoginMD::set_allocated_lgn(::udorx_comm_lite::CLogin* lgn) {
  delete lgn_;
  lgn_ = lgn;
  if (lgn) {
    set_has_lgn();
  } else {
    clear_has_lgn();
  }
  // @@protoc_insertion_point(field_set_allocated:udorx_comm_lite.ClsLoginMD.lgn)
}

// optional int32 RID = 2;
bool ClsLoginMD::has_rid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ClsLoginMD::set_has_rid() {
  _has_bits_[0] |= 0x00000002u;
}
void ClsLoginMD::clear_has_rid() {
  _has_bits_[0] &= ~0x00000002u;
}
void ClsLoginMD::clear_rid() {
  rid_ = 0;
  clear_has_rid();
}
 ::google::protobuf::int32 ClsLoginMD::rid() const {
  // @@protoc_insertion_point(field_get:udorx_comm_lite.ClsLoginMD.RID)
  return rid_;
}
 void ClsLoginMD::set_rid(::google::protobuf::int32 value) {
  set_has_rid();
  rid_ = value;
  // @@protoc_insertion_point(field_set:udorx_comm_lite.ClsLoginMD.RID)
}

// optional string DrName = 3;
bool ClsLoginMD::has_drname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ClsLoginMD::set_has_drname() {
  _has_bits_[0] |= 0x00000004u;
}
void ClsLoginMD::clear_has_drname() {
  _has_bits_[0] &= ~0x00000004u;
}
void ClsLoginMD::clear_drname() {
  drname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_drname();
}
 const ::std::string& ClsLoginMD::drname() const {
  // @@protoc_insertion_point(field_get:udorx_comm_lite.ClsLoginMD.DrName)
  return drname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ClsLoginMD::set_drname(const ::std::string& value) {
  set_has_drname();
  drname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:udorx_comm_lite.ClsLoginMD.DrName)
}
 void ClsLoginMD::set_drname(const char* value) {
  set_has_drname();
  drname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:udorx_comm_lite.ClsLoginMD.DrName)
}
 void ClsLoginMD::set_drname(const char* value, size_t size) {
  set_has_drname();
  drname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:udorx_comm_lite.ClsLoginMD.DrName)
}
 ::std::string* ClsLoginMD::mutable_drname() {
  set_has_drname();
  // @@protoc_insertion_point(field_mutable:udorx_comm_lite.ClsLoginMD.DrName)
  return drname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ClsLoginMD::release_drname() {
  clear_has_drname();
  return drname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ClsLoginMD::set_allocated_drname(::std::string* drname) {
  if (drname != NULL) {
    set_has_drname();
  } else {
    clear_has_drname();
  }
  drname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), drname);
  // @@protoc_insertion_point(field_set_allocated:udorx_comm_lite.ClsLoginMD.DrName)
}

// optional .udorx_comm_lite.PCSList cs_stations = 4;
bool ClsLoginMD::has_cs_stations() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ClsLoginMD::set_has_cs_stations() {
  _has_bits_[0] |= 0x00000008u;
}
void ClsLoginMD::clear_has_cs_stations() {
  _has_bits_[0] &= ~0x00000008u;
}
void ClsLoginMD::clear_cs_stations() {
  if (cs_stations_ != NULL) cs_stations_->::udorx_comm_lite::PCSList::Clear();
  clear_has_cs_stations();
}
const ::udorx_comm_lite::PCSList& ClsLoginMD::cs_stations() const {
  // @@protoc_insertion_point(field_get:udorx_comm_lite.ClsLoginMD.cs_stations)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return cs_stations_ != NULL ? *cs_stations_ : *default_instance().cs_stations_;
#else
  return cs_stations_ != NULL ? *cs_stations_ : *default_instance_->cs_stations_;
#endif
}
::udorx_comm_lite::PCSList* ClsLoginMD::mutable_cs_stations() {
  set_has_cs_stations();
  if (cs_stations_ == NULL) {
    cs_stations_ = new ::udorx_comm_lite::PCSList;
  }
  // @@protoc_insertion_point(field_mutable:udorx_comm_lite.ClsLoginMD.cs_stations)
  return cs_stations_;
}
::udorx_comm_lite::PCSList* ClsLoginMD::release_cs_stations() {
  clear_has_cs_stations();
  ::udorx_comm_lite::PCSList* temp = cs_stations_;
  cs_stations_ = NULL;
  return temp;
}
void ClsLoginMD::set_allocated_cs_stations(::udorx_comm_lite::PCSList* cs_stations) {
  delete cs_stations_;
  cs_stations_ = cs_stations;
  if (cs_stations) {
    set_has_cs_stations();
  } else {
    clear_has_cs_stations();
  }
  // @@protoc_insertion_point(field_set_allocated:udorx_comm_lite.ClsLoginMD.cs_stations)
}

// optional .udorx_comm_lite.PConf config = 5;
bool ClsLoginMD::has_config() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ClsLoginMD::set_has_config() {
  _has_bits_[0] |= 0x00000010u;
}
void ClsLoginMD::clear_has_config() {
  _has_bits_[0] &= ~0x00000010u;
}
void ClsLoginMD::clear_config() {
  if (config_ != NULL) config_->::udorx_comm_lite::PConf::Clear();
  clear_has_config();
}
const ::udorx_comm_lite::PConf& ClsLoginMD::config() const {
  // @@protoc_insertion_point(field_get:udorx_comm_lite.ClsLoginMD.config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return config_ != NULL ? *config_ : *default_instance().config_;
#else
  return config_ != NULL ? *config_ : *default_instance_->config_;
#endif
}
::udorx_comm_lite::PConf* ClsLoginMD::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    config_ = new ::udorx_comm_lite::PConf;
  }
  // @@protoc_insertion_point(field_mutable:udorx_comm_lite.ClsLoginMD.config)
  return config_;
}
::udorx_comm_lite::PConf* ClsLoginMD::release_config() {
  clear_has_config();
  ::udorx_comm_lite::PConf* temp = config_;
  config_ = NULL;
  return temp;
}
void ClsLoginMD::set_allocated_config(::udorx_comm_lite::PConf* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:udorx_comm_lite.ClsLoginMD.config)
}

// optional .udorx_comm_lite.PEmpl driverProf = 6;
bool ClsLoginMD::has_driverprof() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void ClsLoginMD::set_has_driverprof() {
  _has_bits_[0] |= 0x00000020u;
}
void ClsLoginMD::clear_has_driverprof() {
  _has_bits_[0] &= ~0x00000020u;
}
void ClsLoginMD::clear_driverprof() {
  if (driverprof_ != NULL) driverprof_->::udorx_comm_lite::PEmpl::Clear();
  clear_has_driverprof();
}
const ::udorx_comm_lite::PEmpl& ClsLoginMD::driverprof() const {
  // @@protoc_insertion_point(field_get:udorx_comm_lite.ClsLoginMD.driverProf)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return driverprof_ != NULL ? *driverprof_ : *default_instance().driverprof_;
#else
  return driverprof_ != NULL ? *driverprof_ : *default_instance_->driverprof_;
#endif
}
::udorx_comm_lite::PEmpl* ClsLoginMD::mutable_driverprof() {
  set_has_driverprof();
  if (driverprof_ == NULL) {
    driverprof_ = new ::udorx_comm_lite::PEmpl;
  }
  // @@protoc_insertion_point(field_mutable:udorx_comm_lite.ClsLoginMD.driverProf)
  return driverprof_;
}
::udorx_comm_lite::PEmpl* ClsLoginMD::release_driverprof() {
  clear_has_driverprof();
  ::udorx_comm_lite::PEmpl* temp = driverprof_;
  driverprof_ = NULL;
  return temp;
}
void ClsLoginMD::set_allocated_driverprof(::udorx_comm_lite::PEmpl* driverprof) {
  delete driverprof_;
  driverprof_ = driverprof;
  if (driverprof) {
    set_has_driverprof();
  } else {
    clear_has_driverprof();
  }
  // @@protoc_insertion_point(field_set_allocated:udorx_comm_lite.ClsLoginMD.driverProf)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RttHBResp::kResFieldNumber;
const int RttHBResp::kRidFieldNumber;
const int RttHBResp::kCsListFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RttHBResp::RttHBResp()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:udorx_comm_lite.RttHBResp)
}

void RttHBResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  cs_list_ = const_cast< ::udorx_comm_lite::PCSList*>(
      ::udorx_comm_lite::PCSList::internal_default_instance());
#else
  cs_list_ = const_cast< ::udorx_comm_lite::PCSList*>(&::udorx_comm_lite::PCSList::default_instance());
#endif
}

RttHBResp::RttHBResp(const RttHBResp& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:udorx_comm_lite.RttHBResp)
}

void RttHBResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  res_ = 0;
  rid_ = 0;
  cs_list_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RttHBResp::~RttHBResp() {
  // @@protoc_insertion_point(destructor:udorx_comm_lite.RttHBResp)
  SharedDtor();
}

void RttHBResp::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete cs_list_;
  }
}

void RttHBResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RttHBResp& RttHBResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_udorx_5fcomm_5flite_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_udorx_5fcomm_5flite_2eproto();
#endif
  return *default_instance_;
}

RttHBResp* RttHBResp::default_instance_ = NULL;

RttHBResp* RttHBResp::New(::google::protobuf::Arena* arena) const {
  RttHBResp* n = new RttHBResp;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RttHBResp::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<RttHBResp*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 7u) {
    ZR_(res_, rid_);
    if (has_cs_list()) {
      if (cs_list_ != NULL) cs_list_->::udorx_comm_lite::PCSList::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool RttHBResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:udorx_comm_lite.RttHBResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 res = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &res_)));
          set_has_res();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_rid;
        break;
      }

      // required sint32 rid = 2;
      case 2: {
        if (tag == 16) {
         parse_rid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &rid_)));
          set_has_rid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_cs_list;
        break;
      }

      // optional .udorx_comm_lite.PCSList cs_list = 3;
      case 3: {
        if (tag == 26) {
         parse_cs_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cs_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:udorx_comm_lite.RttHBResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:udorx_comm_lite.RttHBResp)
  return false;
#undef DO_
}

void RttHBResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:udorx_comm_lite.RttHBResp)
  // required int32 res = 1;
  if (has_res()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->res(), output);
  }

  // required sint32 rid = 2;
  if (has_rid()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(2, this->rid(), output);
  }

  // optional .udorx_comm_lite.PCSList cs_list = 3;
  if (has_cs_list()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->cs_list_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:udorx_comm_lite.RttHBResp)
}

int RttHBResp::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_res()) {
    // required int32 res = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->res());
  }

  if (has_rid()) {
    // required sint32 rid = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::SInt32Size(
        this->rid());
  }

  return total_size;
}
int RttHBResp::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int32 res = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->res());

    // required sint32 rid = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::SInt32Size(
        this->rid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional .udorx_comm_lite.PCSList cs_list = 3;
  if (has_cs_list()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->cs_list_);
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RttHBResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RttHBResp*>(&from));
}

void RttHBResp::MergeFrom(const RttHBResp& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_res()) {
      set_res(from.res());
    }
    if (from.has_rid()) {
      set_rid(from.rid());
    }
    if (from.has_cs_list()) {
      mutable_cs_list()->::udorx_comm_lite::PCSList::MergeFrom(from.cs_list());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RttHBResp::CopyFrom(const RttHBResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RttHBResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_cs_list()) {
    if (!this->cs_list_->IsInitialized()) return false;
  }
  return true;
}

void RttHBResp::Swap(RttHBResp* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RttHBResp::InternalSwap(RttHBResp* other) {
  std::swap(res_, other->res_);
  std::swap(rid_, other->rid_);
  std::swap(cs_list_, other->cs_list_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string RttHBResp::GetTypeName() const {
  return "udorx_comm_lite.RttHBResp";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RttHBResp

// required int32 res = 1;
bool RttHBResp::has_res() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RttHBResp::set_has_res() {
  _has_bits_[0] |= 0x00000001u;
}
void RttHBResp::clear_has_res() {
  _has_bits_[0] &= ~0x00000001u;
}
void RttHBResp::clear_res() {
  res_ = 0;
  clear_has_res();
}
 ::google::protobuf::int32 RttHBResp::res() const {
  // @@protoc_insertion_point(field_get:udorx_comm_lite.RttHBResp.res)
  return res_;
}
 void RttHBResp::set_res(::google::protobuf::int32 value) {
  set_has_res();
  res_ = value;
  // @@protoc_insertion_point(field_set:udorx_comm_lite.RttHBResp.res)
}

// required sint32 rid = 2;
bool RttHBResp::has_rid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RttHBResp::set_has_rid() {
  _has_bits_[0] |= 0x00000002u;
}
void RttHBResp::clear_has_rid() {
  _has_bits_[0] &= ~0x00000002u;
}
void RttHBResp::clear_rid() {
  rid_ = 0;
  clear_has_rid();
}
 ::google::protobuf::int32 RttHBResp::rid() const {
  // @@protoc_insertion_point(field_get:udorx_comm_lite.RttHBResp.rid)
  return rid_;
}
 void RttHBResp::set_rid(::google::protobuf::int32 value) {
  set_has_rid();
  rid_ = value;
  // @@protoc_insertion_point(field_set:udorx_comm_lite.RttHBResp.rid)
}

// optional .udorx_comm_lite.PCSList cs_list = 3;
bool RttHBResp::has_cs_list() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RttHBResp::set_has_cs_list() {
  _has_bits_[0] |= 0x00000004u;
}
void RttHBResp::clear_has_cs_list() {
  _has_bits_[0] &= ~0x00000004u;
}
void RttHBResp::clear_cs_list() {
  if (cs_list_ != NULL) cs_list_->::udorx_comm_lite::PCSList::Clear();
  clear_has_cs_list();
}
const ::udorx_comm_lite::PCSList& RttHBResp::cs_list() const {
  // @@protoc_insertion_point(field_get:udorx_comm_lite.RttHBResp.cs_list)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return cs_list_ != NULL ? *cs_list_ : *default_instance().cs_list_;
#else
  return cs_list_ != NULL ? *cs_list_ : *default_instance_->cs_list_;
#endif
}
::udorx_comm_lite::PCSList* RttHBResp::mutable_cs_list() {
  set_has_cs_list();
  if (cs_list_ == NULL) {
    cs_list_ = new ::udorx_comm_lite::PCSList;
  }
  // @@protoc_insertion_point(field_mutable:udorx_comm_lite.RttHBResp.cs_list)
  return cs_list_;
}
::udorx_comm_lite::PCSList* RttHBResp::release_cs_list() {
  clear_has_cs_list();
  ::udorx_comm_lite::PCSList* temp = cs_list_;
  cs_list_ = NULL;
  return temp;
}
void RttHBResp::set_allocated_cs_list(::udorx_comm_lite::PCSList* cs_list) {
  delete cs_list_;
  cs_list_ = cs_list;
  if (cs_list) {
    set_has_cs_list();
  } else {
    clear_has_cs_list();
  }
  // @@protoc_insertion_point(field_set_allocated:udorx_comm_lite.RttHBResp.cs_list)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PIRptMFile::kFnameFieldNumber;
const int PIRptMFile::kPayloadFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PIRptMFile::PIRptMFile()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:udorx_comm_lite.PIRptMFile)
}

void PIRptMFile::InitAsDefaultInstance() {
}

PIRptMFile::PIRptMFile(const PIRptMFile& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:udorx_comm_lite.PIRptMFile)
}

void PIRptMFile::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  fname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  payload_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PIRptMFile::~PIRptMFile() {
  // @@protoc_insertion_point(destructor:udorx_comm_lite.PIRptMFile)
  SharedDtor();
}

void PIRptMFile::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  fname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  payload_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PIRptMFile::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PIRptMFile& PIRptMFile::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_udorx_5fcomm_5flite_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_udorx_5fcomm_5flite_2eproto();
#endif
  return *default_instance_;
}

PIRptMFile* PIRptMFile::default_instance_ = NULL;

PIRptMFile* PIRptMFile::New(::google::protobuf::Arena* arena) const {
  PIRptMFile* n = new PIRptMFile;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PIRptMFile::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_fname()) {
      fname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_payload()) {
      payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool PIRptMFile::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:udorx_comm_lite.PIRptMFile)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string fname = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_fname()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_payload;
        break;
      }

      // required bytes payload = 2;
      case 2: {
        if (tag == 18) {
         parse_payload:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_payload()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:udorx_comm_lite.PIRptMFile)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:udorx_comm_lite.PIRptMFile)
  return false;
#undef DO_
}

void PIRptMFile::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:udorx_comm_lite.PIRptMFile)
  // required string fname = 1;
  if (has_fname()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->fname(), output);
  }

  // required bytes payload = 2;
  if (has_payload()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->payload(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:udorx_comm_lite.PIRptMFile)
}

int PIRptMFile::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_fname()) {
    // required string fname = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->fname());
  }

  if (has_payload()) {
    // required bytes payload = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->payload());
  }

  return total_size;
}
int PIRptMFile::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string fname = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->fname());

    // required bytes payload = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->payload());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PIRptMFile::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PIRptMFile*>(&from));
}

void PIRptMFile::MergeFrom(const PIRptMFile& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_fname()) {
      set_has_fname();
      fname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.fname_);
    }
    if (from.has_payload()) {
      set_has_payload();
      payload_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.payload_);
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PIRptMFile::CopyFrom(const PIRptMFile& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PIRptMFile::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void PIRptMFile::Swap(PIRptMFile* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PIRptMFile::InternalSwap(PIRptMFile* other) {
  fname_.Swap(&other->fname_);
  payload_.Swap(&other->payload_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string PIRptMFile::GetTypeName() const {
  return "udorx_comm_lite.PIRptMFile";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PIRptMFile

// required string fname = 1;
bool PIRptMFile::has_fname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PIRptMFile::set_has_fname() {
  _has_bits_[0] |= 0x00000001u;
}
void PIRptMFile::clear_has_fname() {
  _has_bits_[0] &= ~0x00000001u;
}
void PIRptMFile::clear_fname() {
  fname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fname();
}
 const ::std::string& PIRptMFile::fname() const {
  // @@protoc_insertion_point(field_get:udorx_comm_lite.PIRptMFile.fname)
  return fname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PIRptMFile::set_fname(const ::std::string& value) {
  set_has_fname();
  fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:udorx_comm_lite.PIRptMFile.fname)
}
 void PIRptMFile::set_fname(const char* value) {
  set_has_fname();
  fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:udorx_comm_lite.PIRptMFile.fname)
}
 void PIRptMFile::set_fname(const char* value, size_t size) {
  set_has_fname();
  fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:udorx_comm_lite.PIRptMFile.fname)
}
 ::std::string* PIRptMFile::mutable_fname() {
  set_has_fname();
  // @@protoc_insertion_point(field_mutable:udorx_comm_lite.PIRptMFile.fname)
  return fname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* PIRptMFile::release_fname() {
  clear_has_fname();
  return fname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PIRptMFile::set_allocated_fname(::std::string* fname) {
  if (fname != NULL) {
    set_has_fname();
  } else {
    clear_has_fname();
  }
  fname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fname);
  // @@protoc_insertion_point(field_set_allocated:udorx_comm_lite.PIRptMFile.fname)
}

// required bytes payload = 2;
bool PIRptMFile::has_payload() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void PIRptMFile::set_has_payload() {
  _has_bits_[0] |= 0x00000002u;
}
void PIRptMFile::clear_has_payload() {
  _has_bits_[0] &= ~0x00000002u;
}
void PIRptMFile::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_payload();
}
 const ::std::string& PIRptMFile::payload() const {
  // @@protoc_insertion_point(field_get:udorx_comm_lite.PIRptMFile.payload)
  return payload_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PIRptMFile::set_payload(const ::std::string& value) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:udorx_comm_lite.PIRptMFile.payload)
}
 void PIRptMFile::set_payload(const char* value) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:udorx_comm_lite.PIRptMFile.payload)
}
 void PIRptMFile::set_payload(const void* value, size_t size) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:udorx_comm_lite.PIRptMFile.payload)
}
 ::std::string* PIRptMFile::mutable_payload() {
  set_has_payload();
  // @@protoc_insertion_point(field_mutable:udorx_comm_lite.PIRptMFile.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* PIRptMFile::release_payload() {
  clear_has_payload();
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PIRptMFile::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    set_has_payload();
  } else {
    clear_has_payload();
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:udorx_comm_lite.PIRptMFile.payload)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PMMsgList::kMsgsFieldNumber;
const int PMMsgList::kMfilesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PMMsgList::PMMsgList()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:udorx_comm_lite.PMMsgList)
}

void PMMsgList::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  msgs_ = const_cast< ::udorx_comm_lite::PMsgList*>(
      ::udorx_comm_lite::PMsgList::internal_default_instance());
#else
  msgs_ = const_cast< ::udorx_comm_lite::PMsgList*>(&::udorx_comm_lite::PMsgList::default_instance());
#endif
}

PMMsgList::PMMsgList(const PMMsgList& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:udorx_comm_lite.PMMsgList)
}

void PMMsgList::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  msgs_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PMMsgList::~PMMsgList() {
  // @@protoc_insertion_point(destructor:udorx_comm_lite.PMMsgList)
  SharedDtor();
}

void PMMsgList::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete msgs_;
  }
}

void PMMsgList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PMMsgList& PMMsgList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_udorx_5fcomm_5flite_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_udorx_5fcomm_5flite_2eproto();
#endif
  return *default_instance_;
}

PMMsgList* PMMsgList::default_instance_ = NULL;

PMMsgList* PMMsgList::New(::google::protobuf::Arena* arena) const {
  PMMsgList* n = new PMMsgList;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PMMsgList::Clear() {
  if (has_msgs()) {
    if (msgs_ != NULL) msgs_->::udorx_comm_lite::PMsgList::Clear();
  }
  mfiles_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool PMMsgList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:udorx_comm_lite.PMMsgList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .udorx_comm_lite.PMsgList msgs = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msgs()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_mfiles;
        break;
      }

      // repeated .udorx_comm_lite.PIRptMFile mfiles = 2;
      case 2: {
        if (tag == 18) {
         parse_mfiles:
          DO_(input->IncrementRecursionDepth());
         parse_loop_mfiles:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_mfiles()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_mfiles;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:udorx_comm_lite.PMMsgList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:udorx_comm_lite.PMMsgList)
  return false;
#undef DO_
}

void PMMsgList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:udorx_comm_lite.PMMsgList)
  // required .udorx_comm_lite.PMsgList msgs = 1;
  if (has_msgs()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->msgs_, output);
  }

  // repeated .udorx_comm_lite.PIRptMFile mfiles = 2;
  for (unsigned int i = 0, n = this->mfiles_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->mfiles(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:udorx_comm_lite.PMMsgList)
}

int PMMsgList::ByteSize() const {
  int total_size = 0;

  // required .udorx_comm_lite.PMsgList msgs = 1;
  if (has_msgs()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->msgs_);
  }
  // repeated .udorx_comm_lite.PIRptMFile mfiles = 2;
  total_size += 1 * this->mfiles_size();
  for (int i = 0; i < this->mfiles_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->mfiles(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PMMsgList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PMMsgList*>(&from));
}

void PMMsgList::MergeFrom(const PMMsgList& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  mfiles_.MergeFrom(from.mfiles_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_msgs()) {
      mutable_msgs()->::udorx_comm_lite::PMsgList::MergeFrom(from.msgs());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PMMsgList::CopyFrom(const PMMsgList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PMMsgList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_msgs()) {
    if (!this->msgs_->IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->mfiles())) return false;
  return true;
}

void PMMsgList::Swap(PMMsgList* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PMMsgList::InternalSwap(PMMsgList* other) {
  std::swap(msgs_, other->msgs_);
  mfiles_.UnsafeArenaSwap(&other->mfiles_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string PMMsgList::GetTypeName() const {
  return "udorx_comm_lite.PMMsgList";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PMMsgList

// required .udorx_comm_lite.PMsgList msgs = 1;
bool PMMsgList::has_msgs() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PMMsgList::set_has_msgs() {
  _has_bits_[0] |= 0x00000001u;
}
void PMMsgList::clear_has_msgs() {
  _has_bits_[0] &= ~0x00000001u;
}
void PMMsgList::clear_msgs() {
  if (msgs_ != NULL) msgs_->::udorx_comm_lite::PMsgList::Clear();
  clear_has_msgs();
}
const ::udorx_comm_lite::PMsgList& PMMsgList::msgs() const {
  // @@protoc_insertion_point(field_get:udorx_comm_lite.PMMsgList.msgs)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return msgs_ != NULL ? *msgs_ : *default_instance().msgs_;
#else
  return msgs_ != NULL ? *msgs_ : *default_instance_->msgs_;
#endif
}
::udorx_comm_lite::PMsgList* PMMsgList::mutable_msgs() {
  set_has_msgs();
  if (msgs_ == NULL) {
    msgs_ = new ::udorx_comm_lite::PMsgList;
  }
  // @@protoc_insertion_point(field_mutable:udorx_comm_lite.PMMsgList.msgs)
  return msgs_;
}
::udorx_comm_lite::PMsgList* PMMsgList::release_msgs() {
  clear_has_msgs();
  ::udorx_comm_lite::PMsgList* temp = msgs_;
  msgs_ = NULL;
  return temp;
}
void PMMsgList::set_allocated_msgs(::udorx_comm_lite::PMsgList* msgs) {
  delete msgs_;
  msgs_ = msgs;
  if (msgs) {
    set_has_msgs();
  } else {
    clear_has_msgs();
  }
  // @@protoc_insertion_point(field_set_allocated:udorx_comm_lite.PMMsgList.msgs)
}

// repeated .udorx_comm_lite.PIRptMFile mfiles = 2;
int PMMsgList::mfiles_size() const {
  return mfiles_.size();
}
void PMMsgList::clear_mfiles() {
  mfiles_.Clear();
}
const ::udorx_comm_lite::PIRptMFile& PMMsgList::mfiles(int index) const {
  // @@protoc_insertion_point(field_get:udorx_comm_lite.PMMsgList.mfiles)
  return mfiles_.Get(index);
}
::udorx_comm_lite::PIRptMFile* PMMsgList::mutable_mfiles(int index) {
  // @@protoc_insertion_point(field_mutable:udorx_comm_lite.PMMsgList.mfiles)
  return mfiles_.Mutable(index);
}
::udorx_comm_lite::PIRptMFile* PMMsgList::add_mfiles() {
  // @@protoc_insertion_point(field_add:udorx_comm_lite.PMMsgList.mfiles)
  return mfiles_.Add();
}
::google::protobuf::RepeatedPtrField< ::udorx_comm_lite::PIRptMFile >*
PMMsgList::mutable_mfiles() {
  // @@protoc_insertion_point(field_mutable_list:udorx_comm_lite.PMMsgList.mfiles)
  return &mfiles_;
}
const ::google::protobuf::RepeatedPtrField< ::udorx_comm_lite::PIRptMFile >&
PMMsgList::mfiles() const {
  // @@protoc_insertion_point(field_list:udorx_comm_lite.PMMsgList.mfiles)
  return mfiles_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace udorx_comm_lite

// @@protoc_insertion_point(global_scope)
