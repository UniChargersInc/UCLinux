// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: udorx_comm.proto

#ifndef PROTOBUF_udorx_5fcomm_2eproto__INCLUDED
#define PROTOBUF_udorx_5fcomm_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "udorx_common.pb.h"
// @@protoc_insertion_point(includes)

namespace udorx_pbf {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_udorx_5fcomm_2eproto();
void protobuf_AssignDesc_udorx_5fcomm_2eproto();
void protobuf_ShutdownFile_udorx_5fcomm_2eproto();

class CLogin;
class ClsLoginMD;
class PIRptMFile;
class PMMsgList;
class RttHB;
class RttHBResp;

// ===================================================================

class CLogin : public ::google::protobuf::Message {
 public:
  CLogin();
  virtual ~CLogin();

  CLogin(const CLogin& from);

  inline CLogin& operator=(const CLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CLogin& default_instance();

  void Swap(CLogin* other);

  // implements Message ----------------------------------------------

  inline CLogin* New() const { return New(NULL); }

  CLogin* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CLogin& from);
  void MergeFrom(const CLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CLogin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 res = 1;
  bool has_res() const;
  void clear_res();
  static const int kResFieldNumber = 1;
  ::google::protobuf::int32 res() const;
  void set_res(::google::protobuf::int32 value);

  // required int32 cid = 2;
  bool has_cid() const;
  void clear_cid();
  static const int kCidFieldNumber = 2;
  ::google::protobuf::int32 cid() const;
  void set_cid(::google::protobuf::int32 value);

  // required string user = 3;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 3;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // required string pass = 4;
  bool has_pass() const;
  void clear_pass();
  static const int kPassFieldNumber = 4;
  const ::std::string& pass() const;
  void set_pass(const ::std::string& value);
  void set_pass(const char* value);
  void set_pass(const char* value, size_t size);
  ::std::string* mutable_pass();
  ::std::string* release_pass();
  void set_allocated_pass(::std::string* pass);

  // required string lang = 5;
  bool has_lang() const;
  void clear_lang();
  static const int kLangFieldNumber = 5;
  const ::std::string& lang() const;
  void set_lang(const ::std::string& value);
  void set_lang(const char* value);
  void set_lang(const char* value, size_t size);
  ::std::string* mutable_lang();
  ::std::string* release_lang();
  void set_allocated_lang(::std::string* lang);

  // required int64 si = 6;
  bool has_si() const;
  void clear_si();
  static const int kSiFieldNumber = 6;
  ::google::protobuf::int64 si() const;
  void set_si(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:udorx_pbf.CLogin)
 private:
  inline void set_has_res();
  inline void clear_has_res();
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_pass();
  inline void clear_has_pass();
  inline void set_has_lang();
  inline void clear_has_lang();
  inline void set_has_si();
  inline void clear_has_si();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 res_;
  ::google::protobuf::int32 cid_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  ::google::protobuf::internal::ArenaStringPtr pass_;
  ::google::protobuf::internal::ArenaStringPtr lang_;
  ::google::protobuf::int64 si_;
  friend void  protobuf_AddDesc_udorx_5fcomm_2eproto();
  friend void protobuf_AssignDesc_udorx_5fcomm_2eproto();
  friend void protobuf_ShutdownFile_udorx_5fcomm_2eproto();

  void InitAsDefaultInstance();
  static CLogin* default_instance_;
};
// -------------------------------------------------------------------

class RttHB : public ::google::protobuf::Message {
 public:
  RttHB();
  virtual ~RttHB();

  RttHB(const RttHB& from);

  inline RttHB& operator=(const RttHB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RttHB& default_instance();

  void Swap(RttHB* other);

  // implements Message ----------------------------------------------

  inline RttHB* New() const { return New(NULL); }

  RttHB* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RttHB& from);
  void MergeFrom(const RttHB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RttHB* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required sint32 rid = 1;
  bool has_rid() const;
  void clear_rid();
  static const int kRidFieldNumber = 1;
  ::google::protobuf::int32 rid() const;
  void set_rid(::google::protobuf::int32 value);

  // required float lat = 2;
  bool has_lat() const;
  void clear_lat();
  static const int kLatFieldNumber = 2;
  float lat() const;
  void set_lat(float value);

  // required float lon = 3;
  bool has_lon() const;
  void clear_lon();
  static const int kLonFieldNumber = 3;
  float lon() const;
  void set_lon(float value);

  // required int32 spd = 4;
  bool has_spd() const;
  void clear_spd();
  static const int kSpdFieldNumber = 4;
  ::google::protobuf::int32 spd() const;
  void set_spd(::google::protobuf::int32 value);

  // required int32 cog = 5;
  bool has_cog() const;
  void clear_cog();
  static const int kCogFieldNumber = 5;
  ::google::protobuf::int32 cog() const;
  void set_cog(::google::protobuf::int32 value);

  // required int64 ts = 6;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 6;
  ::google::protobuf::int64 ts() const;
  void set_ts(::google::protobuf::int64 value);

  // optional int32 devtype = 7;
  bool has_devtype() const;
  void clear_devtype();
  static const int kDevtypeFieldNumber = 7;
  ::google::protobuf::int32 devtype() const;
  void set_devtype(::google::protobuf::int32 value);

  // optional string did = 8;
  bool has_did() const;
  void clear_did();
  static const int kDidFieldNumber = 8;
  const ::std::string& did() const;
  void set_did(const ::std::string& value);
  void set_did(const char* value);
  void set_did(const char* value, size_t size);
  ::std::string* mutable_did();
  ::std::string* release_did();
  void set_allocated_did(::std::string* did);

  // optional string sensors = 9;
  bool has_sensors() const;
  void clear_sensors();
  static const int kSensorsFieldNumber = 9;
  const ::std::string& sensors() const;
  void set_sensors(const ::std::string& value);
  void set_sensors(const char* value);
  void set_sensors(const char* value, size_t size);
  ::std::string* mutable_sensors();
  ::std::string* release_sensors();
  void set_allocated_sensors(::std::string* sensors);

  // @@protoc_insertion_point(class_scope:udorx_pbf.RttHB)
 private:
  inline void set_has_rid();
  inline void clear_has_rid();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_spd();
  inline void clear_has_spd();
  inline void set_has_cog();
  inline void clear_has_cog();
  inline void set_has_ts();
  inline void clear_has_ts();
  inline void set_has_devtype();
  inline void clear_has_devtype();
  inline void set_has_did();
  inline void clear_has_did();
  inline void set_has_sensors();
  inline void clear_has_sensors();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 rid_;
  float lat_;
  float lon_;
  ::google::protobuf::int32 spd_;
  ::google::protobuf::int64 ts_;
  ::google::protobuf::int32 cog_;
  ::google::protobuf::int32 devtype_;
  ::google::protobuf::internal::ArenaStringPtr did_;
  ::google::protobuf::internal::ArenaStringPtr sensors_;
  friend void  protobuf_AddDesc_udorx_5fcomm_2eproto();
  friend void protobuf_AssignDesc_udorx_5fcomm_2eproto();
  friend void protobuf_ShutdownFile_udorx_5fcomm_2eproto();

  void InitAsDefaultInstance();
  static RttHB* default_instance_;
};
// -------------------------------------------------------------------

class ClsLoginMD : public ::google::protobuf::Message {
 public:
  ClsLoginMD();
  virtual ~ClsLoginMD();

  ClsLoginMD(const ClsLoginMD& from);

  inline ClsLoginMD& operator=(const ClsLoginMD& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClsLoginMD& default_instance();

  void Swap(ClsLoginMD* other);

  // implements Message ----------------------------------------------

  inline ClsLoginMD* New() const { return New(NULL); }

  ClsLoginMD* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClsLoginMD& from);
  void MergeFrom(const ClsLoginMD& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClsLoginMD* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .udorx_pbf.CLogin lgn = 1;
  bool has_lgn() const;
  void clear_lgn();
  static const int kLgnFieldNumber = 1;
  const ::udorx_pbf::CLogin& lgn() const;
  ::udorx_pbf::CLogin* mutable_lgn();
  ::udorx_pbf::CLogin* release_lgn();
  void set_allocated_lgn(::udorx_pbf::CLogin* lgn);

  // optional int32 RID = 2;
  bool has_rid() const;
  void clear_rid();
  static const int kRIDFieldNumber = 2;
  ::google::protobuf::int32 rid() const;
  void set_rid(::google::protobuf::int32 value);

  // optional string DrName = 3;
  bool has_drname() const;
  void clear_drname();
  static const int kDrNameFieldNumber = 3;
  const ::std::string& drname() const;
  void set_drname(const ::std::string& value);
  void set_drname(const char* value);
  void set_drname(const char* value, size_t size);
  ::std::string* mutable_drname();
  ::std::string* release_drname();
  void set_allocated_drname(::std::string* drname);

  // optional .udorx_pbf.PCSList cs_stations = 4;
  bool has_cs_stations() const;
  void clear_cs_stations();
  static const int kCsStationsFieldNumber = 4;
  const ::udorx_pbf::PCSList& cs_stations() const;
  ::udorx_pbf::PCSList* mutable_cs_stations();
  ::udorx_pbf::PCSList* release_cs_stations();
  void set_allocated_cs_stations(::udorx_pbf::PCSList* cs_stations);

  // optional .udorx_pbf.PConf config = 5;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 5;
  const ::udorx_pbf::PConf& config() const;
  ::udorx_pbf::PConf* mutable_config();
  ::udorx_pbf::PConf* release_config();
  void set_allocated_config(::udorx_pbf::PConf* config);

  // optional .udorx_pbf.PEmpl driverProf = 6;
  bool has_driverprof() const;
  void clear_driverprof();
  static const int kDriverProfFieldNumber = 6;
  const ::udorx_pbf::PEmpl& driverprof() const;
  ::udorx_pbf::PEmpl* mutable_driverprof();
  ::udorx_pbf::PEmpl* release_driverprof();
  void set_allocated_driverprof(::udorx_pbf::PEmpl* driverprof);

  // @@protoc_insertion_point(class_scope:udorx_pbf.ClsLoginMD)
 private:
  inline void set_has_lgn();
  inline void clear_has_lgn();
  inline void set_has_rid();
  inline void clear_has_rid();
  inline void set_has_drname();
  inline void clear_has_drname();
  inline void set_has_cs_stations();
  inline void clear_has_cs_stations();
  inline void set_has_config();
  inline void clear_has_config();
  inline void set_has_driverprof();
  inline void clear_has_driverprof();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::udorx_pbf::CLogin* lgn_;
  ::google::protobuf::internal::ArenaStringPtr drname_;
  ::udorx_pbf::PCSList* cs_stations_;
  ::udorx_pbf::PConf* config_;
  ::udorx_pbf::PEmpl* driverprof_;
  ::google::protobuf::int32 rid_;
  friend void  protobuf_AddDesc_udorx_5fcomm_2eproto();
  friend void protobuf_AssignDesc_udorx_5fcomm_2eproto();
  friend void protobuf_ShutdownFile_udorx_5fcomm_2eproto();

  void InitAsDefaultInstance();
  static ClsLoginMD* default_instance_;
};
// -------------------------------------------------------------------

class RttHBResp : public ::google::protobuf::Message {
 public:
  RttHBResp();
  virtual ~RttHBResp();

  RttHBResp(const RttHBResp& from);

  inline RttHBResp& operator=(const RttHBResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RttHBResp& default_instance();

  void Swap(RttHBResp* other);

  // implements Message ----------------------------------------------

  inline RttHBResp* New() const { return New(NULL); }

  RttHBResp* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RttHBResp& from);
  void MergeFrom(const RttHBResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RttHBResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 res = 1;
  bool has_res() const;
  void clear_res();
  static const int kResFieldNumber = 1;
  ::google::protobuf::int32 res() const;
  void set_res(::google::protobuf::int32 value);

  // required sint32 rid = 2;
  bool has_rid() const;
  void clear_rid();
  static const int kRidFieldNumber = 2;
  ::google::protobuf::int32 rid() const;
  void set_rid(::google::protobuf::int32 value);

  // optional .udorx_pbf.PCSList cs_list = 3;
  bool has_cs_list() const;
  void clear_cs_list();
  static const int kCsListFieldNumber = 3;
  const ::udorx_pbf::PCSList& cs_list() const;
  ::udorx_pbf::PCSList* mutable_cs_list();
  ::udorx_pbf::PCSList* release_cs_list();
  void set_allocated_cs_list(::udorx_pbf::PCSList* cs_list);

  // @@protoc_insertion_point(class_scope:udorx_pbf.RttHBResp)
 private:
  inline void set_has_res();
  inline void clear_has_res();
  inline void set_has_rid();
  inline void clear_has_rid();
  inline void set_has_cs_list();
  inline void clear_has_cs_list();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 res_;
  ::google::protobuf::int32 rid_;
  ::udorx_pbf::PCSList* cs_list_;
  friend void  protobuf_AddDesc_udorx_5fcomm_2eproto();
  friend void protobuf_AssignDesc_udorx_5fcomm_2eproto();
  friend void protobuf_ShutdownFile_udorx_5fcomm_2eproto();

  void InitAsDefaultInstance();
  static RttHBResp* default_instance_;
};
// -------------------------------------------------------------------

class PIRptMFile : public ::google::protobuf::Message {
 public:
  PIRptMFile();
  virtual ~PIRptMFile();

  PIRptMFile(const PIRptMFile& from);

  inline PIRptMFile& operator=(const PIRptMFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PIRptMFile& default_instance();

  void Swap(PIRptMFile* other);

  // implements Message ----------------------------------------------

  inline PIRptMFile* New() const { return New(NULL); }

  PIRptMFile* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PIRptMFile& from);
  void MergeFrom(const PIRptMFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PIRptMFile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string fname = 1;
  bool has_fname() const;
  void clear_fname();
  static const int kFnameFieldNumber = 1;
  const ::std::string& fname() const;
  void set_fname(const ::std::string& value);
  void set_fname(const char* value);
  void set_fname(const char* value, size_t size);
  ::std::string* mutable_fname();
  ::std::string* release_fname();
  void set_allocated_fname(::std::string* fname);

  // required bytes payload = 2;
  bool has_payload() const;
  void clear_payload();
  static const int kPayloadFieldNumber = 2;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:udorx_pbf.PIRptMFile)
 private:
  inline void set_has_fname();
  inline void clear_has_fname();
  inline void set_has_payload();
  inline void clear_has_payload();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr fname_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  friend void  protobuf_AddDesc_udorx_5fcomm_2eproto();
  friend void protobuf_AssignDesc_udorx_5fcomm_2eproto();
  friend void protobuf_ShutdownFile_udorx_5fcomm_2eproto();

  void InitAsDefaultInstance();
  static PIRptMFile* default_instance_;
};
// -------------------------------------------------------------------

class PMMsgList : public ::google::protobuf::Message {
 public:
  PMMsgList();
  virtual ~PMMsgList();

  PMMsgList(const PMMsgList& from);

  inline PMMsgList& operator=(const PMMsgList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PMMsgList& default_instance();

  void Swap(PMMsgList* other);

  // implements Message ----------------------------------------------

  inline PMMsgList* New() const { return New(NULL); }

  PMMsgList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PMMsgList& from);
  void MergeFrom(const PMMsgList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PMMsgList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .udorx_pbf.PMsgList msgs = 1;
  bool has_msgs() const;
  void clear_msgs();
  static const int kMsgsFieldNumber = 1;
  const ::udorx_pbf::PMsgList& msgs() const;
  ::udorx_pbf::PMsgList* mutable_msgs();
  ::udorx_pbf::PMsgList* release_msgs();
  void set_allocated_msgs(::udorx_pbf::PMsgList* msgs);

  // repeated .udorx_pbf.PIRptMFile mfiles = 2;
  int mfiles_size() const;
  void clear_mfiles();
  static const int kMfilesFieldNumber = 2;
  const ::udorx_pbf::PIRptMFile& mfiles(int index) const;
  ::udorx_pbf::PIRptMFile* mutable_mfiles(int index);
  ::udorx_pbf::PIRptMFile* add_mfiles();
  ::google::protobuf::RepeatedPtrField< ::udorx_pbf::PIRptMFile >*
      mutable_mfiles();
  const ::google::protobuf::RepeatedPtrField< ::udorx_pbf::PIRptMFile >&
      mfiles() const;

  // @@protoc_insertion_point(class_scope:udorx_pbf.PMMsgList)
 private:
  inline void set_has_msgs();
  inline void clear_has_msgs();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::udorx_pbf::PMsgList* msgs_;
  ::google::protobuf::RepeatedPtrField< ::udorx_pbf::PIRptMFile > mfiles_;
  friend void  protobuf_AddDesc_udorx_5fcomm_2eproto();
  friend void protobuf_AssignDesc_udorx_5fcomm_2eproto();
  friend void protobuf_ShutdownFile_udorx_5fcomm_2eproto();

  void InitAsDefaultInstance();
  static PMMsgList* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// CLogin

// required int32 res = 1;
inline bool CLogin::has_res() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CLogin::set_has_res() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CLogin::clear_has_res() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CLogin::clear_res() {
  res_ = 0;
  clear_has_res();
}
inline ::google::protobuf::int32 CLogin::res() const {
  // @@protoc_insertion_point(field_get:udorx_pbf.CLogin.res)
  return res_;
}
inline void CLogin::set_res(::google::protobuf::int32 value) {
  set_has_res();
  res_ = value;
  // @@protoc_insertion_point(field_set:udorx_pbf.CLogin.res)
}

// required int32 cid = 2;
inline bool CLogin::has_cid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CLogin::set_has_cid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CLogin::clear_has_cid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CLogin::clear_cid() {
  cid_ = 0;
  clear_has_cid();
}
inline ::google::protobuf::int32 CLogin::cid() const {
  // @@protoc_insertion_point(field_get:udorx_pbf.CLogin.cid)
  return cid_;
}
inline void CLogin::set_cid(::google::protobuf::int32 value) {
  set_has_cid();
  cid_ = value;
  // @@protoc_insertion_point(field_set:udorx_pbf.CLogin.cid)
}

// required string user = 3;
inline bool CLogin::has_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CLogin::set_has_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CLogin::clear_has_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CLogin::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user();
}
inline const ::std::string& CLogin::user() const {
  // @@protoc_insertion_point(field_get:udorx_pbf.CLogin.user)
  return user_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CLogin::set_user(const ::std::string& value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:udorx_pbf.CLogin.user)
}
inline void CLogin::set_user(const char* value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:udorx_pbf.CLogin.user)
}
inline void CLogin::set_user(const char* value, size_t size) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:udorx_pbf.CLogin.user)
}
inline ::std::string* CLogin::mutable_user() {
  set_has_user();
  // @@protoc_insertion_point(field_mutable:udorx_pbf.CLogin.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CLogin::release_user() {
  clear_has_user();
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CLogin::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    set_has_user();
  } else {
    clear_has_user();
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:udorx_pbf.CLogin.user)
}

// required string pass = 4;
inline bool CLogin::has_pass() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CLogin::set_has_pass() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CLogin::clear_has_pass() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CLogin::clear_pass() {
  pass_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pass();
}
inline const ::std::string& CLogin::pass() const {
  // @@protoc_insertion_point(field_get:udorx_pbf.CLogin.pass)
  return pass_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CLogin::set_pass(const ::std::string& value) {
  set_has_pass();
  pass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:udorx_pbf.CLogin.pass)
}
inline void CLogin::set_pass(const char* value) {
  set_has_pass();
  pass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:udorx_pbf.CLogin.pass)
}
inline void CLogin::set_pass(const char* value, size_t size) {
  set_has_pass();
  pass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:udorx_pbf.CLogin.pass)
}
inline ::std::string* CLogin::mutable_pass() {
  set_has_pass();
  // @@protoc_insertion_point(field_mutable:udorx_pbf.CLogin.pass)
  return pass_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CLogin::release_pass() {
  clear_has_pass();
  return pass_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CLogin::set_allocated_pass(::std::string* pass) {
  if (pass != NULL) {
    set_has_pass();
  } else {
    clear_has_pass();
  }
  pass_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pass);
  // @@protoc_insertion_point(field_set_allocated:udorx_pbf.CLogin.pass)
}

// required string lang = 5;
inline bool CLogin::has_lang() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CLogin::set_has_lang() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CLogin::clear_has_lang() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CLogin::clear_lang() {
  lang_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_lang();
}
inline const ::std::string& CLogin::lang() const {
  // @@protoc_insertion_point(field_get:udorx_pbf.CLogin.lang)
  return lang_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CLogin::set_lang(const ::std::string& value) {
  set_has_lang();
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:udorx_pbf.CLogin.lang)
}
inline void CLogin::set_lang(const char* value) {
  set_has_lang();
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:udorx_pbf.CLogin.lang)
}
inline void CLogin::set_lang(const char* value, size_t size) {
  set_has_lang();
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:udorx_pbf.CLogin.lang)
}
inline ::std::string* CLogin::mutable_lang() {
  set_has_lang();
  // @@protoc_insertion_point(field_mutable:udorx_pbf.CLogin.lang)
  return lang_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CLogin::release_lang() {
  clear_has_lang();
  return lang_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CLogin::set_allocated_lang(::std::string* lang) {
  if (lang != NULL) {
    set_has_lang();
  } else {
    clear_has_lang();
  }
  lang_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lang);
  // @@protoc_insertion_point(field_set_allocated:udorx_pbf.CLogin.lang)
}

// required int64 si = 6;
inline bool CLogin::has_si() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CLogin::set_has_si() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CLogin::clear_has_si() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CLogin::clear_si() {
  si_ = GOOGLE_LONGLONG(0);
  clear_has_si();
}
inline ::google::protobuf::int64 CLogin::si() const {
  // @@protoc_insertion_point(field_get:udorx_pbf.CLogin.si)
  return si_;
}
inline void CLogin::set_si(::google::protobuf::int64 value) {
  set_has_si();
  si_ = value;
  // @@protoc_insertion_point(field_set:udorx_pbf.CLogin.si)
}

// -------------------------------------------------------------------

// RttHB

// required sint32 rid = 1;
inline bool RttHB::has_rid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RttHB::set_has_rid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RttHB::clear_has_rid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RttHB::clear_rid() {
  rid_ = 0;
  clear_has_rid();
}
inline ::google::protobuf::int32 RttHB::rid() const {
  // @@protoc_insertion_point(field_get:udorx_pbf.RttHB.rid)
  return rid_;
}
inline void RttHB::set_rid(::google::protobuf::int32 value) {
  set_has_rid();
  rid_ = value;
  // @@protoc_insertion_point(field_set:udorx_pbf.RttHB.rid)
}

// required float lat = 2;
inline bool RttHB::has_lat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RttHB::set_has_lat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RttHB::clear_has_lat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RttHB::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline float RttHB::lat() const {
  // @@protoc_insertion_point(field_get:udorx_pbf.RttHB.lat)
  return lat_;
}
inline void RttHB::set_lat(float value) {
  set_has_lat();
  lat_ = value;
  // @@protoc_insertion_point(field_set:udorx_pbf.RttHB.lat)
}

// required float lon = 3;
inline bool RttHB::has_lon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RttHB::set_has_lon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RttHB::clear_has_lon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RttHB::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline float RttHB::lon() const {
  // @@protoc_insertion_point(field_get:udorx_pbf.RttHB.lon)
  return lon_;
}
inline void RttHB::set_lon(float value) {
  set_has_lon();
  lon_ = value;
  // @@protoc_insertion_point(field_set:udorx_pbf.RttHB.lon)
}

// required int32 spd = 4;
inline bool RttHB::has_spd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RttHB::set_has_spd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RttHB::clear_has_spd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RttHB::clear_spd() {
  spd_ = 0;
  clear_has_spd();
}
inline ::google::protobuf::int32 RttHB::spd() const {
  // @@protoc_insertion_point(field_get:udorx_pbf.RttHB.spd)
  return spd_;
}
inline void RttHB::set_spd(::google::protobuf::int32 value) {
  set_has_spd();
  spd_ = value;
  // @@protoc_insertion_point(field_set:udorx_pbf.RttHB.spd)
}

// required int32 cog = 5;
inline bool RttHB::has_cog() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RttHB::set_has_cog() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RttHB::clear_has_cog() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RttHB::clear_cog() {
  cog_ = 0;
  clear_has_cog();
}
inline ::google::protobuf::int32 RttHB::cog() const {
  // @@protoc_insertion_point(field_get:udorx_pbf.RttHB.cog)
  return cog_;
}
inline void RttHB::set_cog(::google::protobuf::int32 value) {
  set_has_cog();
  cog_ = value;
  // @@protoc_insertion_point(field_set:udorx_pbf.RttHB.cog)
}

// required int64 ts = 6;
inline bool RttHB::has_ts() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RttHB::set_has_ts() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RttHB::clear_has_ts() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RttHB::clear_ts() {
  ts_ = GOOGLE_LONGLONG(0);
  clear_has_ts();
}
inline ::google::protobuf::int64 RttHB::ts() const {
  // @@protoc_insertion_point(field_get:udorx_pbf.RttHB.ts)
  return ts_;
}
inline void RttHB::set_ts(::google::protobuf::int64 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:udorx_pbf.RttHB.ts)
}

// optional int32 devtype = 7;
inline bool RttHB::has_devtype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RttHB::set_has_devtype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RttHB::clear_has_devtype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RttHB::clear_devtype() {
  devtype_ = 0;
  clear_has_devtype();
}
inline ::google::protobuf::int32 RttHB::devtype() const {
  // @@protoc_insertion_point(field_get:udorx_pbf.RttHB.devtype)
  return devtype_;
}
inline void RttHB::set_devtype(::google::protobuf::int32 value) {
  set_has_devtype();
  devtype_ = value;
  // @@protoc_insertion_point(field_set:udorx_pbf.RttHB.devtype)
}

// optional string did = 8;
inline bool RttHB::has_did() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RttHB::set_has_did() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RttHB::clear_has_did() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RttHB::clear_did() {
  did_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_did();
}
inline const ::std::string& RttHB::did() const {
  // @@protoc_insertion_point(field_get:udorx_pbf.RttHB.did)
  return did_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RttHB::set_did(const ::std::string& value) {
  set_has_did();
  did_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:udorx_pbf.RttHB.did)
}
inline void RttHB::set_did(const char* value) {
  set_has_did();
  did_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:udorx_pbf.RttHB.did)
}
inline void RttHB::set_did(const char* value, size_t size) {
  set_has_did();
  did_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:udorx_pbf.RttHB.did)
}
inline ::std::string* RttHB::mutable_did() {
  set_has_did();
  // @@protoc_insertion_point(field_mutable:udorx_pbf.RttHB.did)
  return did_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RttHB::release_did() {
  clear_has_did();
  return did_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RttHB::set_allocated_did(::std::string* did) {
  if (did != NULL) {
    set_has_did();
  } else {
    clear_has_did();
  }
  did_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), did);
  // @@protoc_insertion_point(field_set_allocated:udorx_pbf.RttHB.did)
}

// optional string sensors = 9;
inline bool RttHB::has_sensors() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RttHB::set_has_sensors() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RttHB::clear_has_sensors() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RttHB::clear_sensors() {
  sensors_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sensors();
}
inline const ::std::string& RttHB::sensors() const {
  // @@protoc_insertion_point(field_get:udorx_pbf.RttHB.sensors)
  return sensors_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RttHB::set_sensors(const ::std::string& value) {
  set_has_sensors();
  sensors_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:udorx_pbf.RttHB.sensors)
}
inline void RttHB::set_sensors(const char* value) {
  set_has_sensors();
  sensors_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:udorx_pbf.RttHB.sensors)
}
inline void RttHB::set_sensors(const char* value, size_t size) {
  set_has_sensors();
  sensors_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:udorx_pbf.RttHB.sensors)
}
inline ::std::string* RttHB::mutable_sensors() {
  set_has_sensors();
  // @@protoc_insertion_point(field_mutable:udorx_pbf.RttHB.sensors)
  return sensors_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RttHB::release_sensors() {
  clear_has_sensors();
  return sensors_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RttHB::set_allocated_sensors(::std::string* sensors) {
  if (sensors != NULL) {
    set_has_sensors();
  } else {
    clear_has_sensors();
  }
  sensors_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sensors);
  // @@protoc_insertion_point(field_set_allocated:udorx_pbf.RttHB.sensors)
}

// -------------------------------------------------------------------

// ClsLoginMD

// required .udorx_pbf.CLogin lgn = 1;
inline bool ClsLoginMD::has_lgn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClsLoginMD::set_has_lgn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClsLoginMD::clear_has_lgn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClsLoginMD::clear_lgn() {
  if (lgn_ != NULL) lgn_->::udorx_pbf::CLogin::Clear();
  clear_has_lgn();
}
inline const ::udorx_pbf::CLogin& ClsLoginMD::lgn() const {
  // @@protoc_insertion_point(field_get:udorx_pbf.ClsLoginMD.lgn)
  return lgn_ != NULL ? *lgn_ : *default_instance_->lgn_;
}
inline ::udorx_pbf::CLogin* ClsLoginMD::mutable_lgn() {
  set_has_lgn();
  if (lgn_ == NULL) {
    lgn_ = new ::udorx_pbf::CLogin;
  }
  // @@protoc_insertion_point(field_mutable:udorx_pbf.ClsLoginMD.lgn)
  return lgn_;
}
inline ::udorx_pbf::CLogin* ClsLoginMD::release_lgn() {
  clear_has_lgn();
  ::udorx_pbf::CLogin* temp = lgn_;
  lgn_ = NULL;
  return temp;
}
inline void ClsLoginMD::set_allocated_lgn(::udorx_pbf::CLogin* lgn) {
  delete lgn_;
  lgn_ = lgn;
  if (lgn) {
    set_has_lgn();
  } else {
    clear_has_lgn();
  }
  // @@protoc_insertion_point(field_set_allocated:udorx_pbf.ClsLoginMD.lgn)
}

// optional int32 RID = 2;
inline bool ClsLoginMD::has_rid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClsLoginMD::set_has_rid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClsLoginMD::clear_has_rid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClsLoginMD::clear_rid() {
  rid_ = 0;
  clear_has_rid();
}
inline ::google::protobuf::int32 ClsLoginMD::rid() const {
  // @@protoc_insertion_point(field_get:udorx_pbf.ClsLoginMD.RID)
  return rid_;
}
inline void ClsLoginMD::set_rid(::google::protobuf::int32 value) {
  set_has_rid();
  rid_ = value;
  // @@protoc_insertion_point(field_set:udorx_pbf.ClsLoginMD.RID)
}

// optional string DrName = 3;
inline bool ClsLoginMD::has_drname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClsLoginMD::set_has_drname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClsLoginMD::clear_has_drname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClsLoginMD::clear_drname() {
  drname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_drname();
}
inline const ::std::string& ClsLoginMD::drname() const {
  // @@protoc_insertion_point(field_get:udorx_pbf.ClsLoginMD.DrName)
  return drname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClsLoginMD::set_drname(const ::std::string& value) {
  set_has_drname();
  drname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:udorx_pbf.ClsLoginMD.DrName)
}
inline void ClsLoginMD::set_drname(const char* value) {
  set_has_drname();
  drname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:udorx_pbf.ClsLoginMD.DrName)
}
inline void ClsLoginMD::set_drname(const char* value, size_t size) {
  set_has_drname();
  drname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:udorx_pbf.ClsLoginMD.DrName)
}
inline ::std::string* ClsLoginMD::mutable_drname() {
  set_has_drname();
  // @@protoc_insertion_point(field_mutable:udorx_pbf.ClsLoginMD.DrName)
  return drname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClsLoginMD::release_drname() {
  clear_has_drname();
  return drname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClsLoginMD::set_allocated_drname(::std::string* drname) {
  if (drname != NULL) {
    set_has_drname();
  } else {
    clear_has_drname();
  }
  drname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), drname);
  // @@protoc_insertion_point(field_set_allocated:udorx_pbf.ClsLoginMD.DrName)
}

// optional .udorx_pbf.PCSList cs_stations = 4;
inline bool ClsLoginMD::has_cs_stations() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClsLoginMD::set_has_cs_stations() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClsLoginMD::clear_has_cs_stations() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClsLoginMD::clear_cs_stations() {
  if (cs_stations_ != NULL) cs_stations_->::udorx_pbf::PCSList::Clear();
  clear_has_cs_stations();
}
inline const ::udorx_pbf::PCSList& ClsLoginMD::cs_stations() const {
  // @@protoc_insertion_point(field_get:udorx_pbf.ClsLoginMD.cs_stations)
  return cs_stations_ != NULL ? *cs_stations_ : *default_instance_->cs_stations_;
}
inline ::udorx_pbf::PCSList* ClsLoginMD::mutable_cs_stations() {
  set_has_cs_stations();
  if (cs_stations_ == NULL) {
    cs_stations_ = new ::udorx_pbf::PCSList;
  }
  // @@protoc_insertion_point(field_mutable:udorx_pbf.ClsLoginMD.cs_stations)
  return cs_stations_;
}
inline ::udorx_pbf::PCSList* ClsLoginMD::release_cs_stations() {
  clear_has_cs_stations();
  ::udorx_pbf::PCSList* temp = cs_stations_;
  cs_stations_ = NULL;
  return temp;
}
inline void ClsLoginMD::set_allocated_cs_stations(::udorx_pbf::PCSList* cs_stations) {
  delete cs_stations_;
  cs_stations_ = cs_stations;
  if (cs_stations) {
    set_has_cs_stations();
  } else {
    clear_has_cs_stations();
  }
  // @@protoc_insertion_point(field_set_allocated:udorx_pbf.ClsLoginMD.cs_stations)
}

// optional .udorx_pbf.PConf config = 5;
inline bool ClsLoginMD::has_config() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClsLoginMD::set_has_config() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClsLoginMD::clear_has_config() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClsLoginMD::clear_config() {
  if (config_ != NULL) config_->::udorx_pbf::PConf::Clear();
  clear_has_config();
}
inline const ::udorx_pbf::PConf& ClsLoginMD::config() const {
  // @@protoc_insertion_point(field_get:udorx_pbf.ClsLoginMD.config)
  return config_ != NULL ? *config_ : *default_instance_->config_;
}
inline ::udorx_pbf::PConf* ClsLoginMD::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    config_ = new ::udorx_pbf::PConf;
  }
  // @@protoc_insertion_point(field_mutable:udorx_pbf.ClsLoginMD.config)
  return config_;
}
inline ::udorx_pbf::PConf* ClsLoginMD::release_config() {
  clear_has_config();
  ::udorx_pbf::PConf* temp = config_;
  config_ = NULL;
  return temp;
}
inline void ClsLoginMD::set_allocated_config(::udorx_pbf::PConf* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:udorx_pbf.ClsLoginMD.config)
}

// optional .udorx_pbf.PEmpl driverProf = 6;
inline bool ClsLoginMD::has_driverprof() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClsLoginMD::set_has_driverprof() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClsLoginMD::clear_has_driverprof() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClsLoginMD::clear_driverprof() {
  if (driverprof_ != NULL) driverprof_->::udorx_pbf::PEmpl::Clear();
  clear_has_driverprof();
}
inline const ::udorx_pbf::PEmpl& ClsLoginMD::driverprof() const {
  // @@protoc_insertion_point(field_get:udorx_pbf.ClsLoginMD.driverProf)
  return driverprof_ != NULL ? *driverprof_ : *default_instance_->driverprof_;
}
inline ::udorx_pbf::PEmpl* ClsLoginMD::mutable_driverprof() {
  set_has_driverprof();
  if (driverprof_ == NULL) {
    driverprof_ = new ::udorx_pbf::PEmpl;
  }
  // @@protoc_insertion_point(field_mutable:udorx_pbf.ClsLoginMD.driverProf)
  return driverprof_;
}
inline ::udorx_pbf::PEmpl* ClsLoginMD::release_driverprof() {
  clear_has_driverprof();
  ::udorx_pbf::PEmpl* temp = driverprof_;
  driverprof_ = NULL;
  return temp;
}
inline void ClsLoginMD::set_allocated_driverprof(::udorx_pbf::PEmpl* driverprof) {
  delete driverprof_;
  driverprof_ = driverprof;
  if (driverprof) {
    set_has_driverprof();
  } else {
    clear_has_driverprof();
  }
  // @@protoc_insertion_point(field_set_allocated:udorx_pbf.ClsLoginMD.driverProf)
}

// -------------------------------------------------------------------

// RttHBResp

// required int32 res = 1;
inline bool RttHBResp::has_res() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RttHBResp::set_has_res() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RttHBResp::clear_has_res() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RttHBResp::clear_res() {
  res_ = 0;
  clear_has_res();
}
inline ::google::protobuf::int32 RttHBResp::res() const {
  // @@protoc_insertion_point(field_get:udorx_pbf.RttHBResp.res)
  return res_;
}
inline void RttHBResp::set_res(::google::protobuf::int32 value) {
  set_has_res();
  res_ = value;
  // @@protoc_insertion_point(field_set:udorx_pbf.RttHBResp.res)
}

// required sint32 rid = 2;
inline bool RttHBResp::has_rid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RttHBResp::set_has_rid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RttHBResp::clear_has_rid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RttHBResp::clear_rid() {
  rid_ = 0;
  clear_has_rid();
}
inline ::google::protobuf::int32 RttHBResp::rid() const {
  // @@protoc_insertion_point(field_get:udorx_pbf.RttHBResp.rid)
  return rid_;
}
inline void RttHBResp::set_rid(::google::protobuf::int32 value) {
  set_has_rid();
  rid_ = value;
  // @@protoc_insertion_point(field_set:udorx_pbf.RttHBResp.rid)
}

// optional .udorx_pbf.PCSList cs_list = 3;
inline bool RttHBResp::has_cs_list() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RttHBResp::set_has_cs_list() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RttHBResp::clear_has_cs_list() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RttHBResp::clear_cs_list() {
  if (cs_list_ != NULL) cs_list_->::udorx_pbf::PCSList::Clear();
  clear_has_cs_list();
}
inline const ::udorx_pbf::PCSList& RttHBResp::cs_list() const {
  // @@protoc_insertion_point(field_get:udorx_pbf.RttHBResp.cs_list)
  return cs_list_ != NULL ? *cs_list_ : *default_instance_->cs_list_;
}
inline ::udorx_pbf::PCSList* RttHBResp::mutable_cs_list() {
  set_has_cs_list();
  if (cs_list_ == NULL) {
    cs_list_ = new ::udorx_pbf::PCSList;
  }
  // @@protoc_insertion_point(field_mutable:udorx_pbf.RttHBResp.cs_list)
  return cs_list_;
}
inline ::udorx_pbf::PCSList* RttHBResp::release_cs_list() {
  clear_has_cs_list();
  ::udorx_pbf::PCSList* temp = cs_list_;
  cs_list_ = NULL;
  return temp;
}
inline void RttHBResp::set_allocated_cs_list(::udorx_pbf::PCSList* cs_list) {
  delete cs_list_;
  cs_list_ = cs_list;
  if (cs_list) {
    set_has_cs_list();
  } else {
    clear_has_cs_list();
  }
  // @@protoc_insertion_point(field_set_allocated:udorx_pbf.RttHBResp.cs_list)
}

// -------------------------------------------------------------------

// PIRptMFile

// required string fname = 1;
inline bool PIRptMFile::has_fname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PIRptMFile::set_has_fname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PIRptMFile::clear_has_fname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PIRptMFile::clear_fname() {
  fname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fname();
}
inline const ::std::string& PIRptMFile::fname() const {
  // @@protoc_insertion_point(field_get:udorx_pbf.PIRptMFile.fname)
  return fname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PIRptMFile::set_fname(const ::std::string& value) {
  set_has_fname();
  fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:udorx_pbf.PIRptMFile.fname)
}
inline void PIRptMFile::set_fname(const char* value) {
  set_has_fname();
  fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:udorx_pbf.PIRptMFile.fname)
}
inline void PIRptMFile::set_fname(const char* value, size_t size) {
  set_has_fname();
  fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:udorx_pbf.PIRptMFile.fname)
}
inline ::std::string* PIRptMFile::mutable_fname() {
  set_has_fname();
  // @@protoc_insertion_point(field_mutable:udorx_pbf.PIRptMFile.fname)
  return fname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PIRptMFile::release_fname() {
  clear_has_fname();
  return fname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PIRptMFile::set_allocated_fname(::std::string* fname) {
  if (fname != NULL) {
    set_has_fname();
  } else {
    clear_has_fname();
  }
  fname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fname);
  // @@protoc_insertion_point(field_set_allocated:udorx_pbf.PIRptMFile.fname)
}

// required bytes payload = 2;
inline bool PIRptMFile::has_payload() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PIRptMFile::set_has_payload() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PIRptMFile::clear_has_payload() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PIRptMFile::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_payload();
}
inline const ::std::string& PIRptMFile::payload() const {
  // @@protoc_insertion_point(field_get:udorx_pbf.PIRptMFile.payload)
  return payload_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PIRptMFile::set_payload(const ::std::string& value) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:udorx_pbf.PIRptMFile.payload)
}
inline void PIRptMFile::set_payload(const char* value) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:udorx_pbf.PIRptMFile.payload)
}
inline void PIRptMFile::set_payload(const void* value, size_t size) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:udorx_pbf.PIRptMFile.payload)
}
inline ::std::string* PIRptMFile::mutable_payload() {
  set_has_payload();
  // @@protoc_insertion_point(field_mutable:udorx_pbf.PIRptMFile.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PIRptMFile::release_payload() {
  clear_has_payload();
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PIRptMFile::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    set_has_payload();
  } else {
    clear_has_payload();
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:udorx_pbf.PIRptMFile.payload)
}

// -------------------------------------------------------------------

// PMMsgList

// required .udorx_pbf.PMsgList msgs = 1;
inline bool PMMsgList::has_msgs() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PMMsgList::set_has_msgs() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PMMsgList::clear_has_msgs() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PMMsgList::clear_msgs() {
  if (msgs_ != NULL) msgs_->::udorx_pbf::PMsgList::Clear();
  clear_has_msgs();
}
inline const ::udorx_pbf::PMsgList& PMMsgList::msgs() const {
  // @@protoc_insertion_point(field_get:udorx_pbf.PMMsgList.msgs)
  return msgs_ != NULL ? *msgs_ : *default_instance_->msgs_;
}
inline ::udorx_pbf::PMsgList* PMMsgList::mutable_msgs() {
  set_has_msgs();
  if (msgs_ == NULL) {
    msgs_ = new ::udorx_pbf::PMsgList;
  }
  // @@protoc_insertion_point(field_mutable:udorx_pbf.PMMsgList.msgs)
  return msgs_;
}
inline ::udorx_pbf::PMsgList* PMMsgList::release_msgs() {
  clear_has_msgs();
  ::udorx_pbf::PMsgList* temp = msgs_;
  msgs_ = NULL;
  return temp;
}
inline void PMMsgList::set_allocated_msgs(::udorx_pbf::PMsgList* msgs) {
  delete msgs_;
  msgs_ = msgs;
  if (msgs) {
    set_has_msgs();
  } else {
    clear_has_msgs();
  }
  // @@protoc_insertion_point(field_set_allocated:udorx_pbf.PMMsgList.msgs)
}

// repeated .udorx_pbf.PIRptMFile mfiles = 2;
inline int PMMsgList::mfiles_size() const {
  return mfiles_.size();
}
inline void PMMsgList::clear_mfiles() {
  mfiles_.Clear();
}
inline const ::udorx_pbf::PIRptMFile& PMMsgList::mfiles(int index) const {
  // @@protoc_insertion_point(field_get:udorx_pbf.PMMsgList.mfiles)
  return mfiles_.Get(index);
}
inline ::udorx_pbf::PIRptMFile* PMMsgList::mutable_mfiles(int index) {
  // @@protoc_insertion_point(field_mutable:udorx_pbf.PMMsgList.mfiles)
  return mfiles_.Mutable(index);
}
inline ::udorx_pbf::PIRptMFile* PMMsgList::add_mfiles() {
  // @@protoc_insertion_point(field_add:udorx_pbf.PMMsgList.mfiles)
  return mfiles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::udorx_pbf::PIRptMFile >*
PMMsgList::mutable_mfiles() {
  // @@protoc_insertion_point(field_mutable_list:udorx_pbf.PMMsgList.mfiles)
  return &mfiles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::udorx_pbf::PIRptMFile >&
PMMsgList::mfiles() const {
  // @@protoc_insertion_point(field_list:udorx_pbf.PMMsgList.mfiles)
  return mfiles_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace udorx_pbf

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_udorx_5fcomm_2eproto__INCLUDED
